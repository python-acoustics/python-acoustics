<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>numpy.lib.function_base &mdash; acoustics 0.0 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="acoustics 0.0 documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">acoustics 0.0 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for numpy.lib.function_base</h1><div class="highlight"><pre>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">print_function</span>

<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">operator</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">numpy.core.numeric</span> <span class="kn">as</span> <span class="nn">_nx</span>
<span class="kn">from</span> <span class="nn">numpy.core</span> <span class="kn">import</span> <span class="n">linspace</span><span class="p">,</span> <span class="n">atleast_1d</span><span class="p">,</span> <span class="n">atleast_2d</span>
<span class="kn">from</span> <span class="nn">numpy.core.numeric</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">ones</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">arange</span><span class="p">,</span> <span class="n">concatenate</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">asarray</span><span class="p">,</span> <span class="n">asanyarray</span><span class="p">,</span> <span class="n">empty</span><span class="p">,</span>
    <span class="n">empty_like</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">,</span> <span class="n">around</span><span class="p">,</span> <span class="n">floor</span><span class="p">,</span> <span class="n">ceil</span><span class="p">,</span> <span class="n">take</span><span class="p">,</span> <span class="n">dot</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">intp</span><span class="p">,</span>
    <span class="n">integer</span><span class="p">,</span> <span class="n">isscalar</span>
    <span class="p">)</span>
<span class="kn">from</span> <span class="nn">numpy.core.umath</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">pi</span><span class="p">,</span> <span class="n">multiply</span><span class="p">,</span> <span class="n">add</span><span class="p">,</span> <span class="n">arctan2</span><span class="p">,</span> <span class="n">frompyfunc</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">less_equal</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span>
    <span class="n">mod</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">log10</span>
    <span class="p">)</span>
<span class="kn">from</span> <span class="nn">numpy.core.fromnumeric</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">ravel</span><span class="p">,</span> <span class="n">nonzero</span><span class="p">,</span> <span class="n">sort</span><span class="p">,</span> <span class="n">partition</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="nb">any</span><span class="p">,</span> <span class="nb">sum</span>
    <span class="p">)</span>
<span class="kn">from</span> <span class="nn">numpy.core.numerictypes</span> <span class="kn">import</span> <span class="n">typecodes</span><span class="p">,</span> <span class="n">number</span>
<span class="kn">from</span> <span class="nn">numpy.lib.twodim_base</span> <span class="kn">import</span> <span class="n">diag</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">deprecate</span>
<span class="kn">from</span> <span class="nn">numpy.core.multiarray</span> <span class="kn">import</span> <span class="n">_insert</span><span class="p">,</span> <span class="n">add_docstring</span>
<span class="kn">from</span> <span class="nn">numpy.core.multiarray</span> <span class="kn">import</span> <span class="n">digitize</span><span class="p">,</span> <span class="n">bincount</span><span class="p">,</span> <span class="n">interp</span> <span class="k">as</span> <span class="n">compiled_interp</span>
<span class="kn">from</span> <span class="nn">numpy.core.umath</span> <span class="kn">import</span> <span class="n">_add_newdoc_ufunc</span> <span class="k">as</span> <span class="n">add_newdoc_ufunc</span>
<span class="kn">from</span> <span class="nn">numpy.compat</span> <span class="kn">import</span> <span class="nb">long</span>

<span class="c1"># Force range to be a generator, for np.delete&#39;s usage.</span>
<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
    <span class="nb">range</span> <span class="o">=</span> <span class="nb">xrange</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;select&#39;</span><span class="p">,</span> <span class="s1">&#39;piecewise&#39;</span><span class="p">,</span> <span class="s1">&#39;trim_zeros&#39;</span><span class="p">,</span> <span class="s1">&#39;copy&#39;</span><span class="p">,</span> <span class="s1">&#39;iterable&#39;</span><span class="p">,</span> <span class="s1">&#39;percentile&#39;</span><span class="p">,</span>
    <span class="s1">&#39;diff&#39;</span><span class="p">,</span> <span class="s1">&#39;gradient&#39;</span><span class="p">,</span> <span class="s1">&#39;angle&#39;</span><span class="p">,</span> <span class="s1">&#39;unwrap&#39;</span><span class="p">,</span> <span class="s1">&#39;sort_complex&#39;</span><span class="p">,</span> <span class="s1">&#39;disp&#39;</span><span class="p">,</span>
    <span class="s1">&#39;extract&#39;</span><span class="p">,</span> <span class="s1">&#39;place&#39;</span><span class="p">,</span> <span class="s1">&#39;vectorize&#39;</span><span class="p">,</span> <span class="s1">&#39;asarray_chkfinite&#39;</span><span class="p">,</span> <span class="s1">&#39;average&#39;</span><span class="p">,</span>
    <span class="s1">&#39;histogram&#39;</span><span class="p">,</span> <span class="s1">&#39;histogramdd&#39;</span><span class="p">,</span> <span class="s1">&#39;bincount&#39;</span><span class="p">,</span> <span class="s1">&#39;digitize&#39;</span><span class="p">,</span> <span class="s1">&#39;cov&#39;</span><span class="p">,</span> <span class="s1">&#39;corrcoef&#39;</span><span class="p">,</span>
    <span class="s1">&#39;msort&#39;</span><span class="p">,</span> <span class="s1">&#39;median&#39;</span><span class="p">,</span> <span class="s1">&#39;sinc&#39;</span><span class="p">,</span> <span class="s1">&#39;hamming&#39;</span><span class="p">,</span> <span class="s1">&#39;hanning&#39;</span><span class="p">,</span> <span class="s1">&#39;bartlett&#39;</span><span class="p">,</span>
    <span class="s1">&#39;blackman&#39;</span><span class="p">,</span> <span class="s1">&#39;kaiser&#39;</span><span class="p">,</span> <span class="s1">&#39;trapz&#39;</span><span class="p">,</span> <span class="s1">&#39;i0&#39;</span><span class="p">,</span> <span class="s1">&#39;add_newdoc&#39;</span><span class="p">,</span> <span class="s1">&#39;add_docstring&#39;</span><span class="p">,</span>
    <span class="s1">&#39;meshgrid&#39;</span><span class="p">,</span> <span class="s1">&#39;delete&#39;</span><span class="p">,</span> <span class="s1">&#39;insert&#39;</span><span class="p">,</span> <span class="s1">&#39;append&#39;</span><span class="p">,</span> <span class="s1">&#39;interp&#39;</span><span class="p">,</span> <span class="s1">&#39;add_newdoc_ufunc&#39;</span>
    <span class="p">]</span>


<span class="k">def</span> <span class="nf">iterable</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check whether or not an object can be iterated over.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : object</span>
<span class="sd">      Input object.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    b : {0, 1}</span>
<span class="sd">      Return 1 if the object has an iterator method or is a sequence,</span>
<span class="sd">      and 0 otherwise.</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.iterable([1, 2, 3])</span>
<span class="sd">    1</span>
<span class="sd">    &gt;&gt;&gt; np.iterable(2)</span>
<span class="sd">    0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="nb">iter</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="mi">1</span>


<span class="k">def</span> <span class="nf">histogram</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">normed</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
              <span class="n">density</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the histogram of a set of data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input data. The histogram is computed over the flattened array.</span>
<span class="sd">    bins : int or sequence of scalars, optional</span>
<span class="sd">        If `bins` is an int, it defines the number of equal-width</span>
<span class="sd">        bins in the given range (10, by default). If `bins` is a sequence,</span>
<span class="sd">        it defines the bin edges, including the rightmost edge, allowing</span>
<span class="sd">        for non-uniform bin widths.</span>
<span class="sd">    range : (float, float), optional</span>
<span class="sd">        The lower and upper range of the bins.  If not provided, range</span>
<span class="sd">        is simply ``(a.min(), a.max())``.  Values outside the range are</span>
<span class="sd">        ignored.</span>
<span class="sd">    normed : bool, optional</span>
<span class="sd">        This keyword is deprecated in Numpy 1.6 due to confusing/buggy</span>
<span class="sd">        behavior. It will be removed in Numpy 2.0. Use the density keyword</span>
<span class="sd">        instead.</span>
<span class="sd">        If False, the result will contain the number of samples</span>
<span class="sd">        in each bin.  If True, the result is the value of the</span>
<span class="sd">        probability *density* function at the bin, normalized such that</span>
<span class="sd">        the *integral* over the range is 1. Note that this latter behavior is</span>
<span class="sd">        known to be buggy with unequal bin widths; use `density` instead.</span>
<span class="sd">    weights : array_like, optional</span>
<span class="sd">        An array of weights, of the same shape as `a`.  Each value in `a`</span>
<span class="sd">        only contributes its associated weight towards the bin count</span>
<span class="sd">        (instead of 1).  If `normed` is True, the weights are normalized,</span>
<span class="sd">        so that the integral of the density over the range remains 1</span>
<span class="sd">    density : bool, optional</span>
<span class="sd">        If False, the result will contain the number of samples</span>
<span class="sd">        in each bin.  If True, the result is the value of the</span>
<span class="sd">        probability *density* function at the bin, normalized such that</span>
<span class="sd">        the *integral* over the range is 1. Note that the sum of the</span>
<span class="sd">        histogram values will not be equal to 1 unless bins of unity</span>
<span class="sd">        width are chosen; it is not a probability *mass* function.</span>
<span class="sd">        Overrides the `normed` keyword if given.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    hist : array</span>
<span class="sd">        The values of the histogram. See `normed` and `weights` for a</span>
<span class="sd">        description of the possible semantics.</span>
<span class="sd">    bin_edges : array of dtype float</span>
<span class="sd">        Return the bin edges ``(length(hist)+1)``.</span>


<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    histogramdd, bincount, searchsorted, digitize</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    All but the last (righthand-most) bin is half-open.  In other words, if</span>
<span class="sd">    `bins` is::</span>

<span class="sd">      [1, 2, 3, 4]</span>

<span class="sd">    then the first bin is ``[1, 2)`` (including 1, but excluding 2) and the</span>
<span class="sd">    second ``[2, 3)``.  The last bin, however, is ``[3, 4]``, which *includes*</span>
<span class="sd">    4.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.histogram([1, 2, 1], bins=[0, 1, 2, 3])</span>
<span class="sd">    (array([0, 2, 1]), array([0, 1, 2, 3]))</span>
<span class="sd">    &gt;&gt;&gt; np.histogram(np.arange(4), bins=np.arange(5), density=True)</span>
<span class="sd">    (array([ 0.25,  0.25,  0.25,  0.25]), array([0, 1, 2, 3, 4]))</span>
<span class="sd">    &gt;&gt;&gt; np.histogram([[1, 2, 1], [1, 0, 1]], bins=[0,1,2,3])</span>
<span class="sd">    (array([1, 4, 1]), array([0, 1, 2, 3]))</span>

<span class="sd">    &gt;&gt;&gt; a = np.arange(5)</span>
<span class="sd">    &gt;&gt;&gt; hist, bin_edges = np.histogram(a, density=True)</span>
<span class="sd">    &gt;&gt;&gt; hist</span>
<span class="sd">    array([ 0.5,  0. ,  0.5,  0. ,  0. ,  0.5,  0. ,  0.5,  0. ,  0.5])</span>
<span class="sd">    &gt;&gt;&gt; hist.sum()</span>
<span class="sd">    2.4999999999999996</span>
<span class="sd">    &gt;&gt;&gt; np.sum(hist*np.diff(bin_edges))</span>
<span class="sd">    1.0</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">a</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">weights</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;weights should have the same shape as a.&#39;</span><span class="p">)</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

    <span class="k">if</span> <span class="p">(</span><span class="nb">range</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">mn</span><span class="p">,</span> <span class="n">mx</span> <span class="o">=</span> <span class="nb">range</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">mn</span> <span class="o">&gt;</span> <span class="n">mx</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="s1">&#39;max must be larger than min in range parameter.&#39;</span><span class="p">)</span>

    <span class="c1"># Histogram is an integer or a float array depending on the weights.</span>
    <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">ntype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ntype</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">dtype</span>

    <span class="c1"># We set a block size, as this allows us to iterate over chunks when</span>
    <span class="c1"># computing histograms, to minimize memory usage.</span>
    <span class="n">BLOCK</span> <span class="o">=</span> <span class="mi">65536</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">iterable</span><span class="p">(</span><span class="n">bins</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="ow">and</span> <span class="n">bins</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;`bins` should be a positive integer.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">range</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># handle empty arrays. Can&#39;t determine range, so use 0-1.</span>
                <span class="nb">range</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">range</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
        <span class="n">mn</span><span class="p">,</span> <span class="n">mx</span> <span class="o">=</span> <span class="p">[</span><span class="n">mi</span> <span class="o">+</span> <span class="mf">0.0</span> <span class="k">for</span> <span class="n">mi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">mn</span> <span class="o">==</span> <span class="n">mx</span><span class="p">:</span>
            <span class="n">mn</span> <span class="o">-=</span> <span class="mf">0.5</span>
            <span class="n">mx</span> <span class="o">+=</span> <span class="mf">0.5</span>
        <span class="c1"># At this point, if the weights are not integer, floating point, or</span>
        <span class="c1"># complex, we have to use the slow algorithm.</span>
        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="n">weights</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span> <span class="ow">or</span>
                                        <span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="n">weights</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)):</span>
            <span class="n">bins</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="n">mn</span><span class="p">,</span> <span class="n">mx</span><span class="p">,</span> <span class="n">bins</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">iterable</span><span class="p">(</span><span class="n">bins</span><span class="p">):</span>
        <span class="c1"># We now convert values of a to bin indices, under the assumption of</span>
        <span class="c1"># equal bin widths (which is valid here).</span>

        <span class="c1"># Initialize empty histogram</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="n">ntype</span><span class="p">)</span>
        <span class="c1"># Pre-compute histogram scaling factor</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">bins</span> <span class="o">/</span> <span class="p">(</span><span class="n">mx</span> <span class="o">-</span> <span class="n">mn</span><span class="p">)</span>

        <span class="c1"># We iterate over blocks here for two reasons: the first is that for</span>
        <span class="c1"># large arrays, it is actually faster (for example for a 10^8 array it</span>
        <span class="c1"># is 2x as fast) and it results in a memory footprint 3x lower in the</span>
        <span class="c1"># limit of large arrays.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">BLOCK</span><span class="p">):</span>
            <span class="n">tmp_a</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">BLOCK</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">tmp_w</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tmp_w</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">BLOCK</span><span class="p">]</span>

            <span class="c1"># Only include values in the right range</span>
            <span class="n">keep</span> <span class="o">=</span> <span class="p">(</span><span class="n">tmp_a</span> <span class="o">&gt;=</span> <span class="n">mn</span><span class="p">)</span>
            <span class="n">keep</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">tmp_a</span> <span class="o">&lt;=</span> <span class="n">mx</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">keep</span><span class="p">):</span>
                <span class="n">tmp_a</span> <span class="o">=</span> <span class="n">tmp_a</span><span class="p">[</span><span class="n">keep</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">tmp_w</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">tmp_w</span> <span class="o">=</span> <span class="n">tmp_w</span><span class="p">[</span><span class="n">keep</span><span class="p">]</span>
            <span class="n">tmp_a</span> <span class="o">=</span> <span class="n">tmp_a</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">tmp_a</span> <span class="o">-=</span> <span class="n">mn</span>
            <span class="n">tmp_a</span> <span class="o">*=</span> <span class="n">norm</span>

            <span class="c1"># Compute the bin indices, and for values that lie exactly on mx we</span>
            <span class="c1"># need to subtract one</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">tmp_a</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
            <span class="n">indices</span><span class="p">[</span><span class="n">indices</span> <span class="o">==</span> <span class="n">bins</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>

            <span class="c1"># We now compute the histogram using bincount</span>
            <span class="k">if</span> <span class="n">ntype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span>
                <span class="n">n</span><span class="o">.</span><span class="n">real</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">tmp_w</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">minlength</span><span class="o">=</span><span class="n">bins</span><span class="p">)</span>
                <span class="n">n</span><span class="o">.</span><span class="n">imag</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">tmp_w</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="n">minlength</span><span class="o">=</span><span class="n">bins</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">tmp_w</span><span class="p">,</span> <span class="n">minlength</span><span class="o">=</span><span class="n">bins</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">ntype</span><span class="p">)</span>

        <span class="c1"># We now compute the bin edges since these are returned</span>
        <span class="n">bins</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="n">mn</span><span class="p">,</span> <span class="n">mx</span><span class="p">,</span> <span class="n">bins</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">bins</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="s1">&#39;bins must increase monotonically.&#39;</span><span class="p">)</span>

        <span class="c1"># Initialize empty histogram</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">bins</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">ntype</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">BLOCK</span><span class="p">):</span>
                <span class="n">sa</span> <span class="o">=</span> <span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">BLOCK</span><span class="p">])</span>
                <span class="n">n</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">sa</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">bins</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;left&#39;</span><span class="p">),</span>
                           <span class="n">sa</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">bins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;right&#39;</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">zero</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ntype</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">BLOCK</span><span class="p">):</span>
                <span class="n">tmp_a</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">BLOCK</span><span class="p">]</span>
                <span class="n">tmp_w</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">BLOCK</span><span class="p">]</span>
                <span class="n">sorting_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">tmp_a</span><span class="p">)</span>
                <span class="n">sa</span> <span class="o">=</span> <span class="n">tmp_a</span><span class="p">[</span><span class="n">sorting_index</span><span class="p">]</span>
                <span class="n">sw</span> <span class="o">=</span> <span class="n">tmp_w</span><span class="p">[</span><span class="n">sorting_index</span><span class="p">]</span>
                <span class="n">cw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="n">zero</span><span class="p">,</span> <span class="p">],</span> <span class="n">sw</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()))</span>
                <span class="n">bin_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">sa</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">bins</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;left&#39;</span><span class="p">),</span>
                                  <span class="n">sa</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">bins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;right&#39;</span><span class="p">)]</span>
                <span class="n">n</span> <span class="o">+=</span> <span class="n">cw</span><span class="p">[</span><span class="n">bin_index</span><span class="p">]</span>


        <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">density</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">density</span><span class="p">:</span>
            <span class="n">db</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">bins</span><span class="p">),</span> <span class="nb">float</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">n</span><span class="o">/</span><span class="n">db</span><span class="o">/</span><span class="n">n</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="n">bins</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">n</span><span class="p">,</span> <span class="n">bins</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># deprecated, buggy behavior. Remove for Numpy 2.0</span>
        <span class="k">if</span> <span class="n">normed</span><span class="p">:</span>
            <span class="n">db</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">bins</span><span class="p">),</span> <span class="nb">float</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">n</span><span class="o">/</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">db</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="n">bins</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">n</span><span class="p">,</span> <span class="n">bins</span>


<span class="k">def</span> <span class="nf">histogramdd</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">normed</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the multidimensional histogram of some data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sample : array_like</span>
<span class="sd">        The data to be histogrammed. It must be an (N,D) array or data</span>
<span class="sd">        that can be converted to such. The rows of the resulting array</span>
<span class="sd">        are the coordinates of points in a D dimensional polytope.</span>
<span class="sd">    bins : sequence or int, optional</span>
<span class="sd">        The bin specification:</span>

<span class="sd">        * A sequence of arrays describing the bin edges along each dimension.</span>
<span class="sd">        * The number of bins for each dimension (nx, ny, ... =bins)</span>
<span class="sd">        * The number of bins for all dimensions (nx=ny=...=bins).</span>

<span class="sd">    range : sequence, optional</span>
<span class="sd">        A sequence of lower and upper bin edges to be used if the edges are</span>
<span class="sd">        not given explicitly in `bins`. Defaults to the minimum and maximum</span>
<span class="sd">        values along each dimension.</span>
<span class="sd">    normed : bool, optional</span>
<span class="sd">        If False, returns the number of samples in each bin. If True,</span>
<span class="sd">        returns the bin density ``bin_count / sample_count / bin_volume``.</span>
<span class="sd">    weights : (N,) array_like, optional</span>
<span class="sd">        An array of values `w_i` weighing each sample `(x_i, y_i, z_i, ...)`.</span>
<span class="sd">        Weights are normalized to 1 if normed is True. If normed is False,</span>
<span class="sd">        the values of the returned histogram are equal to the sum of the</span>
<span class="sd">        weights belonging to the samples falling into each bin.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    H : ndarray</span>
<span class="sd">        The multidimensional histogram of sample x. See normed and weights</span>
<span class="sd">        for the different possible semantics.</span>
<span class="sd">    edges : list</span>
<span class="sd">        A list of D arrays describing the bin edges for each dimension.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    histogram: 1-D histogram</span>
<span class="sd">    histogram2d: 2-D histogram</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; r = np.random.randn(100,3)</span>
<span class="sd">    &gt;&gt;&gt; H, edges = np.histogramdd(r, bins = (5, 8, 4))</span>
<span class="sd">    &gt;&gt;&gt; H.shape, edges[0].size, edges[1].size, edges[2].size</span>
<span class="sd">    ((5, 8, 4), 6, 9, 5)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># Sample is an ND-array.</span>
        <span class="n">N</span><span class="p">,</span> <span class="n">D</span> <span class="o">=</span> <span class="n">sample</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
        <span class="c1"># Sample is a sequence of 1D arrays.</span>
        <span class="n">sample</span> <span class="o">=</span> <span class="n">atleast_2d</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">N</span><span class="p">,</span> <span class="n">D</span> <span class="o">=</span> <span class="n">sample</span><span class="o">.</span><span class="n">shape</span>

    <span class="n">nbin</span> <span class="o">=</span> <span class="n">empty</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="n">D</span><span class="o">*</span><span class="p">[</span><span class="bp">None</span><span class="p">]</span>
    <span class="n">dedges</span> <span class="o">=</span> <span class="n">D</span><span class="o">*</span><span class="p">[</span><span class="bp">None</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">M</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">M</span> <span class="o">!=</span> <span class="n">D</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="s1">&#39;The dimension of bins must be equal to the dimension of the &#39;</span>
                <span class="s1">&#39; sample x.&#39;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="c1"># bins is an integer</span>
        <span class="n">bins</span> <span class="o">=</span> <span class="n">D</span><span class="o">*</span><span class="p">[</span><span class="n">bins</span><span class="p">]</span>

    <span class="c1"># Select range for each dimension</span>
    <span class="c1"># Used only if number of bins is given.</span>
    <span class="k">if</span> <span class="nb">range</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="c1"># Handle empty input. Range can&#39;t be determined in that case, use 0-1.</span>
        <span class="k">if</span> <span class="n">N</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">smin</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
            <span class="n">smax</span> <span class="o">=</span> <span class="n">ones</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">smin</span> <span class="o">=</span> <span class="n">atleast_1d</span><span class="p">(</span><span class="n">array</span><span class="p">(</span><span class="n">sample</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="nb">float</span><span class="p">))</span>
            <span class="n">smax</span> <span class="o">=</span> <span class="n">atleast_1d</span><span class="p">(</span><span class="n">array</span><span class="p">(</span><span class="n">sample</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="nb">float</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">smin</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
        <span class="n">smax</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">arange</span><span class="p">(</span><span class="n">D</span><span class="p">):</span>
            <span class="n">smin</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">smax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">range</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="c1"># Make sure the bins have a finite width.</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">smin</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">smin</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">smax</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">smin</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">smin</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="o">.</span><span class="mi">5</span>
            <span class="n">smax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">smax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="o">.</span><span class="mi">5</span>

    <span class="c1"># avoid rounding issues for comparisons when dealing with inexact types</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">sample</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inexact</span><span class="p">):</span>
        <span class="n">edge_dt</span> <span class="o">=</span> <span class="n">sample</span><span class="o">.</span><span class="n">dtype</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">edge_dt</span> <span class="o">=</span> <span class="nb">float</span>
    <span class="c1"># Create edge arrays</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">arange</span><span class="p">(</span><span class="n">D</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">bins</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">bins</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Element at index </span><span class="si">%s</span><span class="s2"> in `bins` should be a positive &quot;</span>
                    <span class="s2">&quot;integer.&quot;</span> <span class="o">%</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">nbin</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">bins</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span>  <span class="c1"># +2 for outlier bins</span>
            <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="n">smin</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">smax</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nbin</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">edge_dt</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">bins</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">edge_dt</span><span class="p">)</span>
            <span class="n">nbin</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># +1 for outlier bins</span>
        <span class="n">dedges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">dedges</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Found bin edge of size &lt;= 0. Did you specify `bins` with&quot;</span>
                <span class="s2">&quot;non-monotonic sequence?&quot;</span><span class="p">)</span>

    <span class="n">nbin</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">nbin</span><span class="p">)</span>

    <span class="c1"># Handle empty input.</span>
    <span class="k">if</span> <span class="n">N</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nbin</span><span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="n">edges</span>

    <span class="c1"># Compute the bin number each sample falls into.</span>
    <span class="n">Ncount</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">arange</span><span class="p">(</span><span class="n">D</span><span class="p">):</span>
        <span class="n">Ncount</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">digitize</span><span class="p">(</span><span class="n">sample</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="c1"># Using digitize, values that fall on an edge are put in the right bin.</span>
    <span class="c1"># For the rightmost bin, we want values equal to the right edge to be</span>
    <span class="c1"># counted in the last bin, and not as an outlier.</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">arange</span><span class="p">(</span><span class="n">D</span><span class="p">):</span>
        <span class="c1"># Rounding precision</span>
        <span class="n">mindiff</span> <span class="o">=</span> <span class="n">dedges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">mindiff</span><span class="p">):</span>
            <span class="n">decimal</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="n">log10</span><span class="p">(</span><span class="n">mindiff</span><span class="p">))</span> <span class="o">+</span> <span class="mi">6</span>
            <span class="c1"># Find which points are on the rightmost edge.</span>
            <span class="n">not_smaller_than_edge</span> <span class="o">=</span> <span class="p">(</span><span class="n">sample</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">on_edge</span> <span class="o">=</span> <span class="p">(</span><span class="n">around</span><span class="p">(</span><span class="n">sample</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">decimal</span><span class="p">)</span> <span class="o">==</span>
                       <span class="n">around</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">decimal</span><span class="p">))</span>
            <span class="c1"># Shift these points one bin to the left.</span>
            <span class="n">Ncount</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">where</span><span class="p">(</span><span class="n">on_edge</span> <span class="o">&amp;</span> <span class="n">not_smaller_than_edge</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="c1"># Flattened histogram matrix (1D)</span>
    <span class="c1"># Reshape is used so that overlarge arrays</span>
    <span class="c1"># will raise an error.</span>
    <span class="n">hist</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">nbin</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Compute the sample indices in the flattened histogram matrix.</span>
    <span class="n">ni</span> <span class="o">=</span> <span class="n">nbin</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>
    <span class="n">xy</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">D</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">xy</span> <span class="o">+=</span> <span class="n">Ncount</span><span class="p">[</span><span class="n">ni</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">*</span> <span class="n">nbin</span><span class="p">[</span><span class="n">ni</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]]</span><span class="o">.</span><span class="n">prod</span><span class="p">()</span>
    <span class="n">xy</span> <span class="o">+=</span> <span class="n">Ncount</span><span class="p">[</span><span class="n">ni</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

    <span class="c1"># Compute the number of repetitions in xy and assign it to the</span>
    <span class="c1"># flattened histmat.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xy</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">zeros</span><span class="p">(</span><span class="n">nbin</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="n">edges</span>

    <span class="n">flatcount</span> <span class="o">=</span> <span class="n">bincount</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">flatcount</span><span class="p">))</span>
    <span class="n">hist</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">flatcount</span>

    <span class="c1"># Shape into a proper matrix</span>
    <span class="n">hist</span> <span class="o">=</span> <span class="n">hist</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">sort</span><span class="p">(</span><span class="n">nbin</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">arange</span><span class="p">(</span><span class="n">nbin</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">ni</span><span class="o">.</span><span class="n">argsort</span><span class="p">()[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">hist</span> <span class="o">=</span> <span class="n">hist</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
        <span class="n">ni</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ni</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">ni</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">ni</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="c1"># Remove outliers (indices 0 and -1 for each dimension).</span>
    <span class="n">core</span> <span class="o">=</span> <span class="n">D</span><span class="o">*</span><span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
    <span class="n">hist</span> <span class="o">=</span> <span class="n">hist</span><span class="p">[</span><span class="n">core</span><span class="p">]</span>

    <span class="c1"># Normalize if normed is True</span>
    <span class="k">if</span> <span class="n">normed</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">hist</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">arange</span><span class="p">(</span><span class="n">D</span><span class="p">):</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">ones</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
            <span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nbin</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span>
            <span class="n">hist</span> <span class="o">=</span> <span class="n">hist</span> <span class="o">/</span> <span class="n">dedges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">hist</span> <span class="o">/=</span> <span class="n">s</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">hist</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">nbin</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
            <span class="s2">&quot;Internal Shape Error&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">hist</span><span class="p">,</span> <span class="n">edges</span>


<span class="k">def</span> <span class="nf">average</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">returned</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the weighted average along the specified axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Array containing data to be averaged. If `a` is not an array, a</span>
<span class="sd">        conversion is attempted.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis along which to average `a`. If `None`, averaging is done over</span>
<span class="sd">        the flattened array.</span>
<span class="sd">    weights : array_like, optional</span>
<span class="sd">        An array of weights associated with the values in `a`. Each value in</span>
<span class="sd">        `a` contributes to the average according to its associated weight.</span>
<span class="sd">        The weights array can either be 1-D (in which case its length must be</span>
<span class="sd">        the size of `a` along the given axis) or of the same shape as `a`.</span>
<span class="sd">        If `weights=None`, then all data in `a` are assumed to have a</span>
<span class="sd">        weight equal to one.</span>
<span class="sd">    returned : bool, optional</span>
<span class="sd">        Default is `False`. If `True`, the tuple (`average`, `sum_of_weights`)</span>
<span class="sd">        is returned, otherwise only the average is returned.</span>
<span class="sd">        If `weights=None`, `sum_of_weights` is equivalent to the number of</span>
<span class="sd">        elements over which the average is taken.</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    average, [sum_of_weights] : array_type or double</span>
<span class="sd">        Return the average along the specified axis. When returned is `True`,</span>
<span class="sd">        return a tuple with the average as the first element and the sum</span>
<span class="sd">        of the weights as the second element. The return type is `Float`</span>
<span class="sd">        if `a` is of integer type, otherwise it is of the same type as `a`.</span>
<span class="sd">        `sum_of_weights` is of the same type as `average`.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ZeroDivisionError</span>
<span class="sd">        When all weights along axis are zero. See `numpy.ma.average` for a</span>
<span class="sd">        version robust to this type of error.</span>
<span class="sd">    TypeError</span>
<span class="sd">        When the length of 1D `weights` is not the same as the shape of `a`</span>
<span class="sd">        along axis.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    mean</span>

<span class="sd">    ma.average : average for masked arrays -- useful if your data contains</span>
<span class="sd">                 &quot;missing&quot; values</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; data = range(1,5)</span>
<span class="sd">    &gt;&gt;&gt; data</span>
<span class="sd">    [1, 2, 3, 4]</span>
<span class="sd">    &gt;&gt;&gt; np.average(data)</span>
<span class="sd">    2.5</span>
<span class="sd">    &gt;&gt;&gt; np.average(range(1,11), weights=range(10,0,-1))</span>
<span class="sd">    4.0</span>

<span class="sd">    &gt;&gt;&gt; data = np.arange(6).reshape((3,2))</span>
<span class="sd">    &gt;&gt;&gt; data</span>
<span class="sd">    array([[0, 1],</span>
<span class="sd">           [2, 3],</span>
<span class="sd">           [4, 5]])</span>
<span class="sd">    &gt;&gt;&gt; np.average(data, axis=1, weights=[1./4, 3./4])</span>
<span class="sd">    array([ 0.75,  2.75,  4.75])</span>
<span class="sd">    &gt;&gt;&gt; np.average(data, weights=[1./4, 3./4])</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    TypeError: Axis must be specified when shapes of a and weights differ.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">avg</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">scl</span> <span class="o">=</span> <span class="n">avg</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">size</span><span class="o">/</span><span class="n">avg</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="mf">0.0</span>
        <span class="n">wgt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
        <span class="c1"># Sanity checks</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">wgt</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Axis must be specified when shapes of a and weights &quot;</span>
                    <span class="s2">&quot;differ.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">wgt</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;1D weights expected when shapes of a and weights differ.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">wgt</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Length of weights not compatible with specified axis.&quot;</span><span class="p">)</span>

            <span class="c1"># setup wgt to broadcast along axis</span>
            <span class="n">wgt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">wgt</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

        <span class="n">scl</span> <span class="o">=</span> <span class="n">wgt</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">wgt</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">scl</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ZeroDivisionError</span><span class="p">(</span>
                <span class="s2">&quot;Weights sum to zero, can&#39;t be normalized&quot;</span><span class="p">)</span>

        <span class="n">avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">wgt</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span><span class="o">/</span><span class="n">scl</span>

    <span class="k">if</span> <span class="n">returned</span><span class="p">:</span>
        <span class="n">scl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">avg</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">scl</span>
        <span class="k">return</span> <span class="n">avg</span><span class="p">,</span> <span class="n">scl</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">avg</span>


<span class="k">def</span> <span class="nf">asarray_chkfinite</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert the input to an array, checking for NaNs or Infs.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input data, in any form that can be converted to an array.  This</span>
<span class="sd">        includes lists, lists of tuples, tuples, tuples of tuples, tuples</span>
<span class="sd">        of lists and ndarrays.  Success requires no NaNs or Infs.</span>
<span class="sd">    dtype : data-type, optional</span>
<span class="sd">        By default, the data-type is inferred from the input data.</span>
<span class="sd">    order : {&#39;C&#39;, &#39;F&#39;}, optional</span>
<span class="sd">         Whether to use row-major (C-style) or</span>
<span class="sd">         column-major (Fortran-style) memory representation.</span>
<span class="sd">         Defaults to &#39;C&#39;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray</span>
<span class="sd">        Array interpretation of `a`.  No copy is performed if the input</span>
<span class="sd">        is already an ndarray.  If `a` is a subclass of ndarray, a base</span>
<span class="sd">        class ndarray is returned.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        Raises ValueError if `a` contains NaN (Not a Number) or Inf (Infinity).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    asarray : Create and array.</span>
<span class="sd">    asanyarray : Similar function which passes through subclasses.</span>
<span class="sd">    ascontiguousarray : Convert input to a contiguous array.</span>
<span class="sd">    asfarray : Convert input to a floating point ndarray.</span>
<span class="sd">    asfortranarray : Convert input to an ndarray with column-major</span>
<span class="sd">                     memory order.</span>
<span class="sd">    fromiter : Create an array from an iterator.</span>
<span class="sd">    fromfunction : Construct an array by executing a function on grid</span>
<span class="sd">                   positions.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Convert a list into an array.  If all elements are finite</span>
<span class="sd">    ``asarray_chkfinite`` is identical to ``asarray``.</span>

<span class="sd">    &gt;&gt;&gt; a = [1, 2]</span>
<span class="sd">    &gt;&gt;&gt; np.asarray_chkfinite(a, dtype=float)</span>
<span class="sd">    array([1., 2.])</span>

<span class="sd">    Raises ValueError if array_like contains Nans or Infs.</span>

<span class="sd">    &gt;&gt;&gt; a = [1, 2, np.inf]</span>
<span class="sd">    &gt;&gt;&gt; try:</span>
<span class="sd">    ...     np.asarray_chkfinite(a)</span>
<span class="sd">    ... except ValueError:</span>
<span class="sd">    ...     print &#39;ValueError&#39;</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">char</span> <span class="ow">in</span> <span class="n">typecodes</span><span class="p">[</span><span class="s1">&#39;AllFloat&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;array must not contain infs or NaNs&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span>


<span class="k">def</span> <span class="nf">piecewise</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">condlist</span><span class="p">,</span> <span class="n">funclist</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate a piecewise-defined function.</span>

<span class="sd">    Given a set of conditions and corresponding functions, evaluate each</span>
<span class="sd">    function on the input data wherever its condition is true.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : ndarray</span>
<span class="sd">        The input domain.</span>
<span class="sd">    condlist : list of bool arrays</span>
<span class="sd">        Each boolean array corresponds to a function in `funclist`.  Wherever</span>
<span class="sd">        `condlist[i]` is True, `funclist[i](x)` is used as the output value.</span>

<span class="sd">        Each boolean array in `condlist` selects a piece of `x`,</span>
<span class="sd">        and should therefore be of the same shape as `x`.</span>

<span class="sd">        The length of `condlist` must correspond to that of `funclist`.</span>
<span class="sd">        If one extra function is given, i.e. if</span>
<span class="sd">        ``len(funclist) - len(condlist) == 1``, then that extra function</span>
<span class="sd">        is the default value, used wherever all conditions are false.</span>
<span class="sd">    funclist : list of callables, f(x,*args,**kw), or scalars</span>
<span class="sd">        Each function is evaluated over `x` wherever its corresponding</span>
<span class="sd">        condition is True.  It should take an array as input and give an array</span>
<span class="sd">        or a scalar value as output.  If, instead of a callable,</span>
<span class="sd">        a scalar is provided then a constant function (``lambda x: scalar``) is</span>
<span class="sd">        assumed.</span>
<span class="sd">    args : tuple, optional</span>
<span class="sd">        Any further arguments given to `piecewise` are passed to the functions</span>
<span class="sd">        upon execution, i.e., if called ``piecewise(..., ..., 1, &#39;a&#39;)``, then</span>
<span class="sd">        each function is called as ``f(x, 1, &#39;a&#39;)``.</span>
<span class="sd">    kw : dict, optional</span>
<span class="sd">        Keyword arguments used in calling `piecewise` are passed to the</span>
<span class="sd">        functions upon execution, i.e., if called</span>
<span class="sd">        ``piecewise(..., ..., lambda=1)``, then each function is called as</span>
<span class="sd">        ``f(x, lambda=1)``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray</span>
<span class="sd">        The output is the same shape and type as x and is found by</span>
<span class="sd">        calling the functions in `funclist` on the appropriate portions of `x`,</span>
<span class="sd">        as defined by the boolean arrays in `condlist`.  Portions not covered</span>
<span class="sd">        by any condition have a default value of 0.</span>


<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    choose, select, where</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This is similar to choose or select, except that functions are</span>
<span class="sd">    evaluated on elements of `x` that satisfy the corresponding condition from</span>
<span class="sd">    `condlist`.</span>

<span class="sd">    The result is::</span>

<span class="sd">            |--</span>
<span class="sd">            |funclist[0](x[condlist[0]])</span>
<span class="sd">      out = |funclist[1](x[condlist[1]])</span>
<span class="sd">            |...</span>
<span class="sd">            |funclist[n2](x[condlist[n2]])</span>
<span class="sd">            |--</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Define the sigma function, which is -1 for ``x &lt; 0`` and +1 for ``x &gt;= 0``.</span>

<span class="sd">    &gt;&gt;&gt; x = np.linspace(-2.5, 2.5, 6)</span>
<span class="sd">    &gt;&gt;&gt; np.piecewise(x, [x &lt; 0, x &gt;= 0], [-1, 1])</span>
<span class="sd">    array([-1., -1., -1.,  1.,  1.,  1.])</span>

<span class="sd">    Define the absolute value, which is ``-x`` for ``x &lt;0`` and ``x`` for</span>
<span class="sd">    ``x &gt;= 0``.</span>

<span class="sd">    &gt;&gt;&gt; np.piecewise(x, [x &lt; 0, x &gt;= 0], [lambda x: -x, lambda x: x])</span>
<span class="sd">    array([ 2.5,  1.5,  0.5,  0.5,  1.5,  2.5])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">asanyarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">n2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">funclist</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">isscalar</span><span class="p">(</span><span class="n">condlist</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">condlist</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span>
                                   <span class="nb">isinstance</span><span class="p">(</span><span class="n">condlist</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ndarray</span><span class="p">))):</span>
        <span class="n">condlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">condlist</span><span class="p">]</span>
    <span class="n">condlist</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">condlist</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">condlist</span><span class="p">)</span>
    <span class="c1"># This is a hack to work around problems with NumPy&#39;s</span>
    <span class="c1">#  handling of 0-d arrays and boolean indexing with</span>
    <span class="c1">#  numpy.bool_ scalars</span>
    <span class="n">zerod</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="bp">None</span><span class="p">]</span>
        <span class="n">zerod</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="n">condlist</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">condlist</span> <span class="o">=</span> <span class="n">condlist</span><span class="o">.</span><span class="n">T</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="n">n2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># compute the &quot;otherwise&quot; condition.</span>
        <span class="n">totlist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">condlist</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">condlist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">condlist</span><span class="p">,</span> <span class="o">~</span><span class="n">totlist</span><span class="p">])</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="n">n2</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;function list and condition list must be the same&quot;</span><span class="p">)</span>

    <span class="n">y</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">item</span> <span class="o">=</span> <span class="n">funclist</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">Callable</span><span class="p">):</span>
            <span class="n">y</span><span class="p">[</span><span class="n">condlist</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span> <span class="o">=</span> <span class="n">item</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">condlist</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">vals</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">y</span><span class="p">[</span><span class="n">condlist</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span> <span class="o">=</span> <span class="n">item</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">zerod</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">y</span>


<span class="k">def</span> <span class="nf">select</span><span class="p">(</span><span class="n">condlist</span><span class="p">,</span> <span class="n">choicelist</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return an array drawn from elements in choicelist, depending on conditions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    condlist : list of bool ndarrays</span>
<span class="sd">        The list of conditions which determine from which array in `choicelist`</span>
<span class="sd">        the output elements are taken. When multiple conditions are satisfied,</span>
<span class="sd">        the first one encountered in `condlist` is used.</span>
<span class="sd">    choicelist : list of ndarrays</span>
<span class="sd">        The list of arrays from which the output elements are taken. It has</span>
<span class="sd">        to be of the same length as `condlist`.</span>
<span class="sd">    default : scalar, optional</span>
<span class="sd">        The element inserted in `output` when all conditions evaluate to False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    output : ndarray</span>
<span class="sd">        The output at position m is the m-th element of the array in</span>
<span class="sd">        `choicelist` where the m-th element of the corresponding array in</span>
<span class="sd">        `condlist` is True.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    where : Return elements from one of two arrays depending on condition.</span>
<span class="sd">    take, choose, compress, diag, diagonal</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.arange(10)</span>
<span class="sd">    &gt;&gt;&gt; condlist = [x&lt;3, x&gt;5]</span>
<span class="sd">    &gt;&gt;&gt; choicelist = [x, x**2]</span>
<span class="sd">    &gt;&gt;&gt; np.select(condlist, choicelist)</span>
<span class="sd">    array([ 0,  1,  2,  0,  0,  0, 36, 49, 64, 81])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check the size of condlist and choicelist are the same, or abort.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">condlist</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">choicelist</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;list of cases must be same length as list of conditions&#39;</span><span class="p">)</span>

    <span class="c1"># Now that the dtype is known, handle the deprecated select([], []) case</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">condlist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># 2014-02-24, 1.9</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;select with an empty condition list is not possible&quot;</span>
                      <span class="s2">&quot;and will be deprecated&quot;</span><span class="p">,</span>
                      <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">default</span><span class="p">)[()]</span>

    <span class="n">choicelist</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">choice</span><span class="p">)</span> <span class="k">for</span> <span class="n">choice</span> <span class="ow">in</span> <span class="n">choicelist</span><span class="p">]</span>
    <span class="n">choicelist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">default</span><span class="p">))</span>

    <span class="c1"># need to get the result type before broadcasting for correct scalar</span>
    <span class="c1"># behaviour</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="o">*</span><span class="n">choicelist</span><span class="p">)</span>

    <span class="c1"># Convert conditions to arrays and broadcast conditions and choices</span>
    <span class="c1"># as the shape is needed for the result. Doing it seperatly optimizes</span>
    <span class="c1"># for example when all choices are scalars.</span>
    <span class="n">condlist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span><span class="o">*</span><span class="n">condlist</span><span class="p">)</span>
    <span class="n">choicelist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span><span class="o">*</span><span class="n">choicelist</span><span class="p">)</span>

    <span class="c1"># If cond array is not an ndarray in boolean format or scalar bool, abort.</span>
    <span class="n">deprecated_ints</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">condlist</span><span class="p">)):</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">condlist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">cond</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">cond</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
                <span class="c1"># A previous implementation accepted int ndarrays accidentally.</span>
                <span class="c1"># Supported here deliberately, but deprecated.</span>
                <span class="n">condlist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">condlist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
                <span class="n">deprecated_ints</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;invalid entry in choicelist: should be boolean ndarray&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">deprecated_ints</span><span class="p">:</span>
        <span class="c1"># 2014-02-24, 1.9</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;select condlists containing integer ndarrays is deprecated &quot;</span> \
            <span class="s2">&quot;and will be removed in the future. Use `.astype(bool)` to &quot;</span> \
            <span class="s2">&quot;convert to bools.&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">choicelist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># This may be common, so avoid the call.</span>
        <span class="n">result_shape</span> <span class="o">=</span> <span class="n">condlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">result_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span><span class="n">condlist</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">choicelist</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">result_shape</span><span class="p">,</span> <span class="n">choicelist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="p">)</span>

    <span class="c1"># Use np.copyto to burn each choicelist array onto result, using the</span>
    <span class="c1"># corresponding condlist as a boolean mask. This is done in reverse</span>
    <span class="c1"># order since the first choice should take precedence.</span>
    <span class="n">choicelist</span> <span class="o">=</span> <span class="n">choicelist</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">condlist</span> <span class="o">=</span> <span class="n">condlist</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">choice</span><span class="p">,</span> <span class="n">cond</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">choicelist</span><span class="p">,</span> <span class="n">condlist</span><span class="p">):</span>
        <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">choice</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">cond</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;K&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return an array copy of the given object.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input data.</span>
<span class="sd">    order : {&#39;C&#39;, &#39;F&#39;, &#39;A&#39;, &#39;K&#39;}, optional</span>
<span class="sd">        Controls the memory layout of the copy. &#39;C&#39; means C-order,</span>
<span class="sd">        &#39;F&#39; means F-order, &#39;A&#39; means &#39;F&#39; if `a` is Fortran contiguous,</span>
<span class="sd">        &#39;C&#39; otherwise. &#39;K&#39; means match the layout of `a` as closely</span>
<span class="sd">        as possible. (Note that this function and :meth:ndarray.copy are very</span>
<span class="sd">        similar, but have different default values for their order=</span>
<span class="sd">        arguments.)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    arr : ndarray</span>
<span class="sd">        Array interpretation of `a`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This is equivalent to</span>

<span class="sd">    &gt;&gt;&gt; np.array(a, copy=True)                              #doctest: +SKIP</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Create an array x, with a reference y and a copy z:</span>

<span class="sd">    &gt;&gt;&gt; x = np.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; y = x</span>
<span class="sd">    &gt;&gt;&gt; z = np.copy(x)</span>

<span class="sd">    Note that, when we modify x, y changes, but not z:</span>

<span class="sd">    &gt;&gt;&gt; x[0] = 10</span>
<span class="sd">    &gt;&gt;&gt; x[0] == y[0]</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; x[0] == z[0]</span>
<span class="sd">    False</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="c1"># Basic operations</span>


<span class="k">def</span> <span class="nf">gradient</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">varargs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the gradient of an N-dimensional array.</span>

<span class="sd">    The gradient is computed using second order accurate central differences</span>
<span class="sd">    in the interior and either first differences or second order accurate</span>
<span class="sd">    one-sides (forward or backwards) differences at the boundaries. The</span>
<span class="sd">    returned gradient hence has the same shape as the input array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    f : array_like</span>
<span class="sd">        An N-dimensional array containing samples of a scalar function.</span>
<span class="sd">    varargs : list of scalar, optional</span>
<span class="sd">        N scalars specifying the sample distances for each dimension,</span>
<span class="sd">        i.e. `dx`, `dy`, `dz`, ... Default distance: 1.</span>
<span class="sd">    edge_order : {1, 2}, optional</span>
<span class="sd">        Gradient is calculated using N\ :sup:`th` order accurate differences</span>
<span class="sd">        at the boundaries. Default: 1.</span>

<span class="sd">        .. versionadded:: 1.9.1</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    gradient : list of ndarray</span>
<span class="sd">        Each element of `list` has the same shape as `f` giving the derivative </span>
<span class="sd">        of `f` with respect to each dimension.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.array([1, 2, 4, 7, 11, 16], dtype=np.float)</span>
<span class="sd">    &gt;&gt;&gt; np.gradient(x)</span>
<span class="sd">    array([ 1. ,  1.5,  2.5,  3.5,  4.5,  5. ])</span>
<span class="sd">    &gt;&gt;&gt; np.gradient(x, 2)</span>
<span class="sd">    array([ 0.5 ,  0.75,  1.25,  1.75,  2.25,  2.5 ])</span>

<span class="sd">    For two dimensional arrays, the return will be two arrays ordered by </span>
<span class="sd">    axis. In this example the first array stands for the gradient in </span>
<span class="sd">    rows and the second one in columns direction:</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; np.gradient(np.array([[1, 2, 6], [3, 4, 5]], dtype=np.float))</span>
<span class="sd">    [array([[ 2.,  2., -1.],</span>
<span class="sd">            [ 2.,  2., -1.]]), array([[ 1. ,  2.5,  4. ],</span>
<span class="sd">            [ 1. ,  1. ,  1. ]])]</span>

<span class="sd">    &gt;&gt;&gt; x = np.array([0, 1, 2, 3, 4])</span>
<span class="sd">    &gt;&gt;&gt; dx = np.gradient(x)</span>
<span class="sd">    &gt;&gt;&gt; y = x**2</span>
<span class="sd">    &gt;&gt;&gt; np.gradient(y, dx, edge_order=2)</span>
<span class="sd">    array([-0.,  2.,  4.,  6.,  8.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>  <span class="c1"># number of dimensions</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">varargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">]</span><span class="o">*</span><span class="n">N</span>
    <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="p">[</span><span class="n">varargs</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">*</span><span class="n">N</span>
    <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="n">N</span><span class="p">:</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">varargs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span>
            <span class="s2">&quot;invalid number of arguments&quot;</span><span class="p">)</span>

    <span class="n">edge_order</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;edge_order&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;&quot;{}&quot; are not valid keyword arguments.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                  <span class="s1">&#39;&quot;, &quot;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">())))</span>
    <span class="k">if</span> <span class="n">edge_order</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;edge_order&#39; greater than 2 not supported&quot;</span><span class="p">)</span>

    <span class="c1"># use central differences on interior and one-sided differences on the</span>
    <span class="c1"># endpoints. This preserves second order-accuracy over the full domain.</span>

    <span class="n">outvals</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># create slice objects --- initially all are [:, :, ..., :]</span>
    <span class="n">slice1</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">)]</span><span class="o">*</span><span class="n">N</span>
    <span class="n">slice2</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">)]</span><span class="o">*</span><span class="n">N</span>
    <span class="n">slice3</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">)]</span><span class="o">*</span><span class="n">N</span>
    <span class="n">slice4</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">)]</span><span class="o">*</span><span class="n">N</span>

    <span class="n">otype</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">char</span>
    <span class="k">if</span> <span class="n">otype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="s1">&#39;m&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">]:</span>
        <span class="n">otype</span> <span class="o">=</span> <span class="s1">&#39;d&#39;</span>

    <span class="c1"># Difference of datetime64 elements results in timedelta64</span>
    <span class="k">if</span> <span class="n">otype</span> <span class="o">==</span> <span class="s1">&#39;M&#39;</span><span class="p">:</span>
        <span class="c1"># Need to use the full dtype name because it contains unit information</span>
        <span class="n">otype</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;datetime&#39;</span><span class="p">,</span> <span class="s1">&#39;timedelta&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">otype</span> <span class="o">==</span> <span class="s1">&#39;m&#39;</span><span class="p">:</span>
        <span class="c1"># Needs to keep the specific units, can&#39;t be a general unit</span>
        <span class="n">otype</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">dtype</span>

    <span class="c1"># Convert datetime64 data into ints. Make dummy variable `y`</span>
    <span class="c1"># that is a view of ints if the data is datetime64, otherwise</span>
    <span class="c1"># just set y equal to the the array `f`.</span>
    <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">char</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;M&quot;</span><span class="p">,</span> <span class="s2">&quot;m&quot;</span><span class="p">]:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="s1">&#39;int64&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">f</span>

    <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Shape of array too small to calculate a numerical gradient, &quot;</span>
                <span class="s2">&quot;at least two elements are required.&quot;</span><span class="p">)</span>

        <span class="c1"># Numerical differentiation: 1st order edges, 2nd order interior</span>
        <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">edge_order</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Use first order differences for time data</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">otype</span><span class="p">)</span>

            <span class="n">slice1</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">slice2</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
            <span class="n">slice3</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
            <span class="c1"># 1D equivalent -- out[1:-1] = (y[2:] - y[:-2])/2.0</span>
            <span class="n">out</span><span class="p">[</span><span class="n">slice1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">slice2</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">slice3</span><span class="p">])</span><span class="o">/</span><span class="mf">2.0</span>

            <span class="n">slice1</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">slice2</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">slice3</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># 1D equivalent -- out[0] = (y[1] - y[0])</span>
            <span class="n">out</span><span class="p">[</span><span class="n">slice1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">slice2</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">slice3</span><span class="p">])</span>

            <span class="n">slice1</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">slice2</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">slice3</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
            <span class="c1"># 1D equivalent -- out[-1] = (y[-1] - y[-2])</span>
            <span class="n">out</span><span class="p">[</span><span class="n">slice1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">slice2</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">slice3</span><span class="p">])</span>

        <span class="c1"># Numerical differentiation: 2st order edges, 2nd order interior</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Use second order differences where possible</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">otype</span><span class="p">)</span>

            <span class="n">slice1</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">slice2</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
            <span class="n">slice3</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
            <span class="c1"># 1D equivalent -- out[1:-1] = (y[2:] - y[:-2])/2.0</span>
            <span class="n">out</span><span class="p">[</span><span class="n">slice1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">slice2</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">slice3</span><span class="p">])</span><span class="o">/</span><span class="mf">2.0</span>

            <span class="n">slice1</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">slice2</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">slice3</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">slice4</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="c1"># 1D equivalent -- out[0] = -(3*y[0] - 4*y[1] + y[2]) / 2.0</span>
            <span class="n">out</span><span class="p">[</span><span class="n">slice1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="mf">3.0</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="n">slice2</span><span class="p">]</span> <span class="o">-</span> <span class="mf">4.0</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="n">slice3</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="n">slice4</span><span class="p">])</span><span class="o">/</span><span class="mf">2.0</span>

            <span class="n">slice1</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">slice2</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">slice3</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
            <span class="n">slice4</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">3</span>
            <span class="c1"># 1D equivalent -- out[-1] = (3*y[-1] - 4*y[-2] + y[-3])</span>
            <span class="n">out</span><span class="p">[</span><span class="n">slice1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">3.0</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="n">slice2</span><span class="p">]</span> <span class="o">-</span> <span class="mf">4.0</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="n">slice3</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="n">slice4</span><span class="p">])</span><span class="o">/</span><span class="mf">2.0</span>

        <span class="c1"># divide by step size</span>
        <span class="n">out</span> <span class="o">/=</span> <span class="n">dx</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
        <span class="n">outvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

        <span class="c1"># reset the slice object in this dimension to &quot;:&quot;</span>
        <span class="n">slice1</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
        <span class="n">slice2</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
        <span class="n">slice3</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
        <span class="n">slice4</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">N</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">outvals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">outvals</span>


<span class="k">def</span> <span class="nf">diff</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the n-th order discrete difference along given axis.</span>

<span class="sd">    The first order difference is given by ``out[n] = a[n+1] - a[n]`` along</span>
<span class="sd">    the given axis, higher order differences are calculated by using `diff`</span>
<span class="sd">    recursively.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input array</span>
<span class="sd">    n : int, optional</span>
<span class="sd">        The number of times values are differenced.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        The axis along which the difference is taken, default is the last axis.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    diff : ndarray</span>
<span class="sd">        The `n` order differences. The shape of the output is the same as `a`</span>
<span class="sd">        except along `axis` where the dimension is smaller by `n`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    gradient, ediff1d, cumsum</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.array([1, 2, 4, 7, 0])</span>
<span class="sd">    &gt;&gt;&gt; np.diff(x)</span>
<span class="sd">    array([ 1,  2,  3, -7])</span>
<span class="sd">    &gt;&gt;&gt; np.diff(x, n=2)</span>
<span class="sd">    array([  1,   1, -10])</span>

<span class="sd">    &gt;&gt;&gt; x = np.array([[1, 3, 6, 10], [0, 5, 6, 8]])</span>
<span class="sd">    &gt;&gt;&gt; np.diff(x)</span>
<span class="sd">    array([[2, 3, 4],</span>
<span class="sd">           [5, 1, 2]])</span>
<span class="sd">    &gt;&gt;&gt; np.diff(x, axis=0)</span>
<span class="sd">    array([[-1,  2,  0, -2]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">a</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;order must be non-negative but got &quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">nd</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">slice1</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">)]</span><span class="o">*</span><span class="n">nd</span>
    <span class="n">slice2</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">)]</span><span class="o">*</span><span class="n">nd</span>
    <span class="n">slice1</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
    <span class="n">slice2</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">slice1</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">slice1</span><span class="p">)</span>
    <span class="n">slice2</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">slice2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">diff</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">slice1</span><span class="p">]</span><span class="o">-</span><span class="n">a</span><span class="p">[</span><span class="n">slice2</span><span class="p">],</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="n">slice1</span><span class="p">]</span><span class="o">-</span><span class="n">a</span><span class="p">[</span><span class="n">slice2</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">interp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">period</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    One-dimensional linear interpolation.</span>

<span class="sd">    Returns the one-dimensional piecewise linear interpolant to a function</span>
<span class="sd">    with given values at discrete data-points.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like</span>
<span class="sd">        The x-coordinates of the interpolated values.</span>

<span class="sd">    xp : 1-D sequence of floats</span>
<span class="sd">        The x-coordinates of the data points, must be increasing if argument</span>
<span class="sd">        `period` is not specified. Otherwise, `xp` is internally sorted after</span>
<span class="sd">        normalizing the periodic boundaries with ``xp = xp % period``.</span>

<span class="sd">    fp : 1-D sequence of floats</span>
<span class="sd">        The y-coordinates of the data points, same length as `xp`.</span>

<span class="sd">    left : float, optional</span>
<span class="sd">        Value to return for `x &lt; xp[0]`, default is `fp[0]`.</span>

<span class="sd">    right : float, optional</span>
<span class="sd">        Value to return for `x &gt; xp[-1]`, default is `fp[-1]`.</span>

<span class="sd">    period : None or float, optional</span>
<span class="sd">        A period for the x-coordinates. This parameter allows the proper</span>
<span class="sd">        interpolation of angular x-coordinates. Parameters `left` and `right`</span>
<span class="sd">        are ignored if `period` is specified.</span>

<span class="sd">        .. versionadded:: 1.10.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : float or ndarray</span>
<span class="sd">        The interpolated values, same shape as `x`.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If `xp` and `fp` have different length</span>
<span class="sd">        If `xp` or `fp` are not 1-D sequences</span>
<span class="sd">        If `period == 0`</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Does not check that the x-coordinate sequence `xp` is increasing.</span>
<span class="sd">    If `xp` is not increasing, the results are nonsense.</span>
<span class="sd">    A simple check for increasing is::</span>

<span class="sd">        np.all(np.diff(xp) &gt; 0)</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; xp = [1, 2, 3]</span>
<span class="sd">    &gt;&gt;&gt; fp = [3, 2, 0]</span>
<span class="sd">    &gt;&gt;&gt; np.interp(2.5, xp, fp)</span>
<span class="sd">    1.0</span>
<span class="sd">    &gt;&gt;&gt; np.interp([0, 1, 1.5, 2.72, 3.14], xp, fp)</span>
<span class="sd">    array([ 3. ,  3. ,  2.5 ,  0.56,  0. ])</span>
<span class="sd">    &gt;&gt;&gt; UNDEF = -99.0</span>
<span class="sd">    &gt;&gt;&gt; np.interp(3.14, xp, fp, right=UNDEF)</span>
<span class="sd">    -99.0</span>

<span class="sd">    Plot an interpolant to the sine function:</span>

<span class="sd">    &gt;&gt;&gt; x = np.linspace(0, 2*np.pi, 10)</span>
<span class="sd">    &gt;&gt;&gt; y = np.sin(x)</span>
<span class="sd">    &gt;&gt;&gt; xvals = np.linspace(0, 2*np.pi, 50)</span>
<span class="sd">    &gt;&gt;&gt; yinterp = np.interp(xvals, x, y)</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(x, y, &#39;o&#39;)</span>
<span class="sd">    [&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(xvals, yinterp, &#39;-x&#39;)</span>
<span class="sd">    [&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    Interpolation with periodic x-coordinates:</span>

<span class="sd">    &gt;&gt;&gt; x = [-180, -170, -185, 185, -10, -5, 0, 365]</span>
<span class="sd">    &gt;&gt;&gt; xp = [190, -190, 350, -350]</span>
<span class="sd">    &gt;&gt;&gt; fp = [5, 10, 3, 4]</span>
<span class="sd">    &gt;&gt;&gt; np.interp(x, xp, fp, period=360)</span>
<span class="sd">    array([7.5, 5., 8.75, 6.25, 3., 3.25, 3.5, 3.75])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">period</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">number</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">compiled_interp</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="n">xp</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">compiled_interp</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="n">xp</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">compiled_interp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">period</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;period must be a non-zero value&quot;</span><span class="p">)</span>
        <span class="n">period</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">period</span><span class="p">)</span>
        <span class="n">left</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">right</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">return_array</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">number</span><span class="p">)):</span>
            <span class="n">return_array</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">xp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">xp</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">fp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">xp</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">fp</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Data points must be 1-D sequences&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">xp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">fp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;fp and xp are not of the same length&quot;</span><span class="p">)</span>
        <span class="c1"># normalizing periodic boundaries</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">%</span> <span class="n">period</span>
        <span class="n">xp</span> <span class="o">=</span> <span class="n">xp</span> <span class="o">%</span> <span class="n">period</span>
        <span class="n">asort_xp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">xp</span><span class="p">)</span>
        <span class="n">xp</span> <span class="o">=</span> <span class="n">xp</span><span class="p">[</span><span class="n">asort_xp</span><span class="p">]</span>
        <span class="n">fp</span> <span class="o">=</span> <span class="n">fp</span><span class="p">[</span><span class="n">asort_xp</span><span class="p">]</span>
        <span class="n">xp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">xp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span><span class="o">-</span><span class="n">period</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">xp</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">period</span><span class="p">))</span>
        <span class="n">fp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">fp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:],</span> <span class="n">fp</span><span class="p">,</span> <span class="n">fp</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">return_array</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">compiled_interp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">compiled_interp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">angle</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the angle of the complex argument.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    z : array_like</span>
<span class="sd">        A complex number or sequence of complex numbers.</span>
<span class="sd">    deg : bool, optional</span>
<span class="sd">        Return angle in degrees if True, radians if False (default).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    angle : ndarray or scalar</span>
<span class="sd">        The counterclockwise angle from the positive real axis on</span>
<span class="sd">        the complex plane, with dtype as numpy.float64.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    arctan2</span>
<span class="sd">    absolute</span>



<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.angle([1.0, 1.0j, 1+1j])               # in radians</span>
<span class="sd">    array([ 0.        ,  1.57079633,  0.78539816])</span>
<span class="sd">    &gt;&gt;&gt; np.angle(1+1j, deg=True)                  # in degrees</span>
<span class="sd">    45.0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">deg</span><span class="p">:</span>
        <span class="n">fact</span> <span class="o">=</span> <span class="mi">180</span><span class="o">/</span><span class="n">pi</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fact</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">issubclass</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">_nx</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">)):</span>
        <span class="n">zimag</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">imag</span>
        <span class="n">zreal</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">real</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">zimag</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">zreal</span> <span class="o">=</span> <span class="n">z</span>
    <span class="k">return</span> <span class="n">arctan2</span><span class="p">(</span><span class="n">zimag</span><span class="p">,</span> <span class="n">zreal</span><span class="p">)</span> <span class="o">*</span> <span class="n">fact</span>


<span class="k">def</span> <span class="nf">unwrap</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">discont</span><span class="o">=</span><span class="n">pi</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Unwrap by changing deltas between values to 2*pi complement.</span>

<span class="sd">    Unwrap radian phase `p` by changing absolute jumps greater than</span>
<span class="sd">    `discont` to their 2*pi complement along the given axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    p : array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    discont : float, optional</span>
<span class="sd">        Maximum discontinuity between values, default is ``pi``.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis along which unwrap will operate, default is the last axis.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray</span>
<span class="sd">        Output array.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    rad2deg, deg2rad</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If the discontinuity in `p` is smaller than ``pi``, but larger than</span>
<span class="sd">    `discont`, no unwrapping is done because taking the 2*pi complement</span>
<span class="sd">    would only make the discontinuity larger.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; phase = np.linspace(0, np.pi, num=5)</span>
<span class="sd">    &gt;&gt;&gt; phase[3:] += np.pi</span>
<span class="sd">    &gt;&gt;&gt; phase</span>
<span class="sd">    array([ 0.        ,  0.78539816,  1.57079633,  5.49778714,  6.28318531])</span>
<span class="sd">    &gt;&gt;&gt; np.unwrap(phase)</span>
<span class="sd">    array([ 0.        ,  0.78539816,  1.57079633, -0.78539816,  0.        ])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">nd</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">dd</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">slice1</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">)]</span><span class="o">*</span><span class="n">nd</span>     <span class="c1"># full slices</span>
    <span class="n">slice1</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
    <span class="n">ddmod</span> <span class="o">=</span> <span class="n">mod</span><span class="p">(</span><span class="n">dd</span> <span class="o">+</span> <span class="n">pi</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span> <span class="o">-</span> <span class="n">pi</span>
    <span class="n">_nx</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">ddmod</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="p">(</span><span class="n">ddmod</span> <span class="o">==</span> <span class="o">-</span><span class="n">pi</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dd</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
    <span class="n">ph_correct</span> <span class="o">=</span> <span class="n">ddmod</span> <span class="o">-</span> <span class="n">dd</span>
    <span class="n">_nx</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">ph_correct</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="nb">abs</span><span class="p">(</span><span class="n">dd</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">discont</span><span class="p">)</span>
    <span class="n">up</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;d&#39;</span><span class="p">)</span>
    <span class="n">up</span><span class="p">[</span><span class="n">slice1</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">slice1</span><span class="p">]</span> <span class="o">+</span> <span class="n">ph_correct</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">up</span>


<span class="k">def</span> <span class="nf">sort_complex</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sort a complex array using the real part first, then the imaginary part.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input array</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : complex ndarray</span>
<span class="sd">        Always returns a sorted complex array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.sort_complex([5, 3, 6, 2, 1])</span>
<span class="sd">    array([ 1.+0.j,  2.+0.j,  3.+0.j,  5.+0.j,  6.+0.j])</span>

<span class="sd">    &gt;&gt;&gt; np.sort_complex([1 + 2j, 2 - 1j, 3 - 2j, 3 - 3j, 3 + 5j])</span>
<span class="sd">    array([ 1.+2.j,  2.-1.j,  3.-3.j,  3.-2.j,  3.+5.j])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">b</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">_nx</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">char</span> <span class="ow">in</span> <span class="s1">&#39;bhBH&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">b</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">b</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">char</span> <span class="o">==</span> <span class="s1">&#39;g&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">b</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;G&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">b</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;D&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">b</span>


<span class="k">def</span> <span class="nf">trim_zeros</span><span class="p">(</span><span class="n">filt</span><span class="p">,</span> <span class="n">trim</span><span class="o">=</span><span class="s1">&#39;fb&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Trim the leading and/or trailing zeros from a 1-D array or sequence.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filt : 1-D array or sequence</span>
<span class="sd">        Input array.</span>
<span class="sd">    trim : str, optional</span>
<span class="sd">        A string with &#39;f&#39; representing trim from front and &#39;b&#39; to trim from</span>
<span class="sd">        back. Default is &#39;fb&#39;, trim zeros from both front and back of the</span>
<span class="sd">        array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    trimmed : 1-D array or sequence</span>
<span class="sd">        The result of trimming the input. The input data type is preserved.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.array((0, 0, 0, 1, 2, 3, 0, 2, 1, 0))</span>
<span class="sd">    &gt;&gt;&gt; np.trim_zeros(a)</span>
<span class="sd">    array([1, 2, 3, 0, 2, 1])</span>

<span class="sd">    &gt;&gt;&gt; np.trim_zeros(a, &#39;b&#39;)</span>
<span class="sd">    array([0, 0, 0, 1, 2, 3, 0, 2, 1])</span>

<span class="sd">    The input data type is preserved, list/tuple in means list/tuple out.</span>

<span class="sd">    &gt;&gt;&gt; np.trim_zeros([0, 1, 2, 0])</span>
<span class="sd">    [1, 2]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">first</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">trim</span> <span class="o">=</span> <span class="n">trim</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
    <span class="k">if</span> <span class="s1">&#39;F&#39;</span> <span class="ow">in</span> <span class="n">trim</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">filt</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="mf">0.</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">first</span> <span class="o">=</span> <span class="n">first</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">last</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">filt</span><span class="p">)</span>
    <span class="k">if</span> <span class="s1">&#39;B&#39;</span> <span class="ow">in</span> <span class="n">trim</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">filt</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="mf">0.</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">last</span> <span class="o">=</span> <span class="n">last</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">filt</span><span class="p">[</span><span class="n">first</span><span class="p">:</span><span class="n">last</span><span class="p">]</span>


<span class="nd">@deprecate</span>
<span class="k">def</span> <span class="nf">unique</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function is deprecated.  Use numpy.lib.arraysetops.unique()</span>
<span class="sd">    instead.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">tmp</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tmp</span>
        <span class="n">tmp</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(([</span><span class="bp">True</span><span class="p">],</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">!=</span> <span class="n">tmp</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">tmp</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="n">items</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">asarray</span><span class="p">(</span><span class="n">items</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">extract</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">arr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the elements of an array that satisfy some condition.</span>

<span class="sd">    This is equivalent to ``np.compress(ravel(condition), ravel(arr))``.  If</span>
<span class="sd">    `condition` is boolean ``np.extract`` is equivalent to ``arr[condition]``.</span>

<span class="sd">    Note that `place` does the exact opposite of `extract`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    condition : array_like</span>
<span class="sd">        An array whose nonzero or True entries indicate the elements of `arr`</span>
<span class="sd">        to extract.</span>
<span class="sd">    arr : array_like</span>
<span class="sd">        Input array of the same size as `condition`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    extract : ndarray</span>
<span class="sd">        Rank 1 array of values from `arr` where `condition` is True.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    take, put, copyto, compress, place</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; arr = np.arange(12).reshape((3, 4))</span>
<span class="sd">    &gt;&gt;&gt; arr</span>
<span class="sd">    array([[ 0,  1,  2,  3],</span>
<span class="sd">           [ 4,  5,  6,  7],</span>
<span class="sd">           [ 8,  9, 10, 11]])</span>
<span class="sd">    &gt;&gt;&gt; condition = np.mod(arr, 3)==0</span>
<span class="sd">    &gt;&gt;&gt; condition</span>
<span class="sd">    array([[ True, False, False,  True],</span>
<span class="sd">           [False, False,  True, False],</span>
<span class="sd">           [False,  True, False, False]], dtype=bool)</span>
<span class="sd">    &gt;&gt;&gt; np.extract(condition, arr)</span>
<span class="sd">    array([0, 3, 6, 9])</span>


<span class="sd">    If `condition` is boolean:</span>

<span class="sd">    &gt;&gt;&gt; arr[condition]</span>
<span class="sd">    array([0, 3, 6, 9])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_nx</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">ravel</span><span class="p">(</span><span class="n">arr</span><span class="p">),</span> <span class="n">nonzero</span><span class="p">(</span><span class="n">ravel</span><span class="p">(</span><span class="n">condition</span><span class="p">))[</span><span class="mi">0</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">place</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">vals</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Change elements of an array based on conditional and input values.</span>

<span class="sd">    Similar to ``np.copyto(arr, vals, where=mask)``, the difference is that</span>
<span class="sd">    `place` uses the first N elements of `vals`, where N is the number of</span>
<span class="sd">    True values in `mask`, while `copyto` uses the elements where `mask`</span>
<span class="sd">    is True.</span>

<span class="sd">    Note that `extract` does the exact opposite of `place`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : array_like</span>
<span class="sd">        Array to put data into.</span>
<span class="sd">    mask : array_like</span>
<span class="sd">        Boolean mask array. Must have the same size as `a`.</span>
<span class="sd">    vals : 1-D sequence</span>
<span class="sd">        Values to put into `a`. Only the first N elements are used, where</span>
<span class="sd">        N is the number of True values in `mask`. If `vals` is smaller</span>
<span class="sd">        than N it will be repeated.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    copyto, put, take, extract</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; arr = np.arange(6).reshape(2, 3)</span>
<span class="sd">    &gt;&gt;&gt; np.place(arr, arr&gt;2, [44, 55])</span>
<span class="sd">    &gt;&gt;&gt; arr</span>
<span class="sd">    array([[ 0,  1,  2],</span>
<span class="sd">           [44, 55, 44]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_insert</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">vals</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">disp</span><span class="p">(</span><span class="n">mesg</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">linefeed</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Display a message on a device.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mesg : str</span>
<span class="sd">        Message to display.</span>
<span class="sd">    device : object</span>
<span class="sd">        Device to write message. If None, defaults to ``sys.stdout`` which is</span>
<span class="sd">        very similar to ``print``. `device` needs to have ``write()`` and</span>
<span class="sd">        ``flush()`` methods.</span>
<span class="sd">    linefeed : bool, optional</span>
<span class="sd">        Option whether to print a line feed or not. Defaults to True.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    AttributeError</span>
<span class="sd">        If `device` does not have a ``write()`` or ``flush()`` method.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Besides ``sys.stdout``, a file-like object can also be used as it has</span>
<span class="sd">    both required methods:</span>

<span class="sd">    &gt;&gt;&gt; from StringIO import StringIO</span>
<span class="sd">    &gt;&gt;&gt; buf = StringIO()</span>
<span class="sd">    &gt;&gt;&gt; np.disp(&#39;&quot;Display&quot; in a file&#39;, device=buf)</span>
<span class="sd">    &gt;&gt;&gt; buf.getvalue()</span>
<span class="sd">    &#39;&quot;Display&quot; in a file\\n&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">device</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">device</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span>
    <span class="k">if</span> <span class="n">linefeed</span><span class="p">:</span>
        <span class="n">device</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">mesg</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">device</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">mesg</span><span class="p">)</span>
    <span class="n">device</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
    <span class="k">return</span>


<span class="k">class</span> <span class="nc">vectorize</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    vectorize(pyfunc, otypes=&#39;&#39;, doc=None, excluded=None, cache=False)</span>

<span class="sd">    Generalized function class.</span>

<span class="sd">    Define a vectorized function which takes a nested sequence</span>
<span class="sd">    of objects or numpy arrays as inputs and returns a</span>
<span class="sd">    numpy array as output. The vectorized function evaluates `pyfunc` over</span>
<span class="sd">    successive tuples of the input arrays like the python map function,</span>
<span class="sd">    except it uses the broadcasting rules of numpy.</span>

<span class="sd">    The data type of the output of `vectorized` is determined by calling</span>
<span class="sd">    the function with the first element of the input.  This can be avoided</span>
<span class="sd">    by specifying the `otypes` argument.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pyfunc : callable</span>
<span class="sd">        A python function or method.</span>
<span class="sd">    otypes : str or list of dtypes, optional</span>
<span class="sd">        The output data type. It must be specified as either a string of</span>
<span class="sd">        typecode characters or a list of data type specifiers. There should</span>
<span class="sd">        be one data type specifier for each output.</span>
<span class="sd">    doc : str, optional</span>
<span class="sd">        The docstring for the function. If `None`, the docstring will be the</span>
<span class="sd">        ``pyfunc.__doc__``.</span>
<span class="sd">    excluded : set, optional</span>
<span class="sd">        Set of strings or integers representing the positional or keyword</span>
<span class="sd">        arguments for which the function will not be vectorized.  These will be</span>
<span class="sd">        passed directly to `pyfunc` unmodified.</span>

<span class="sd">        .. versionadded:: 1.7.0</span>

<span class="sd">    cache : bool, optional</span>
<span class="sd">       If `True`, then cache the first function call that determines the number</span>
<span class="sd">       of outputs if `otypes` is not provided.</span>

<span class="sd">        .. versionadded:: 1.7.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    vectorized : callable</span>
<span class="sd">        Vectorized function.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; def myfunc(a, b):</span>
<span class="sd">    ...     &quot;Return a-b if a&gt;b, otherwise return a+b&quot;</span>
<span class="sd">    ...     if a &gt; b:</span>
<span class="sd">    ...         return a - b</span>
<span class="sd">    ...     else:</span>
<span class="sd">    ...         return a + b</span>

<span class="sd">    &gt;&gt;&gt; vfunc = np.vectorize(myfunc)</span>
<span class="sd">    &gt;&gt;&gt; vfunc([1, 2, 3, 4], 2)</span>
<span class="sd">    array([3, 4, 1, 2])</span>

<span class="sd">    The docstring is taken from the input function to `vectorize` unless it</span>
<span class="sd">    is specified</span>

<span class="sd">    &gt;&gt;&gt; vfunc.__doc__</span>
<span class="sd">    &#39;Return a-b if a&gt;b, otherwise return a+b&#39;</span>
<span class="sd">    &gt;&gt;&gt; vfunc = np.vectorize(myfunc, doc=&#39;Vectorized `myfunc`&#39;)</span>
<span class="sd">    &gt;&gt;&gt; vfunc.__doc__</span>
<span class="sd">    &#39;Vectorized `myfunc`&#39;</span>

<span class="sd">    The output type is determined by evaluating the first element of the input,</span>
<span class="sd">    unless it is specified</span>

<span class="sd">    &gt;&gt;&gt; out = vfunc([1, 2, 3, 4], 2)</span>
<span class="sd">    &gt;&gt;&gt; type(out[0])</span>
<span class="sd">    &lt;type &#39;numpy.int32&#39;&gt;</span>
<span class="sd">    &gt;&gt;&gt; vfunc = np.vectorize(myfunc, otypes=[np.float])</span>
<span class="sd">    &gt;&gt;&gt; out = vfunc([1, 2, 3, 4], 2)</span>
<span class="sd">    &gt;&gt;&gt; type(out[0])</span>
<span class="sd">    &lt;type &#39;numpy.float64&#39;&gt;</span>

<span class="sd">    The `excluded` argument can be used to prevent vectorizing over certain</span>
<span class="sd">    arguments.  This can be useful for array-like arguments of a fixed length</span>
<span class="sd">    such as the coefficients for a polynomial as in `polyval`:</span>

<span class="sd">    &gt;&gt;&gt; def mypolyval(p, x):</span>
<span class="sd">    ...     _p = list(p)</span>
<span class="sd">    ...     res = _p.pop(0)</span>
<span class="sd">    ...     while _p:</span>
<span class="sd">    ...         res = res*x + _p.pop(0)</span>
<span class="sd">    ...     return res</span>
<span class="sd">    &gt;&gt;&gt; vpolyval = np.vectorize(mypolyval, excluded=[&#39;p&#39;])</span>
<span class="sd">    &gt;&gt;&gt; vpolyval(p=[1, 2, 3], x=[0, 1])</span>
<span class="sd">    array([3, 6])</span>

<span class="sd">    Positional arguments may also be excluded by specifying their position:</span>

<span class="sd">    &gt;&gt;&gt; vpolyval.excluded.add(0)</span>
<span class="sd">    &gt;&gt;&gt; vpolyval([1, 2, 3], x=[0, 1])</span>
<span class="sd">    array([3, 6])</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The `vectorize` function is provided primarily for convenience, not for</span>
<span class="sd">    performance. The implementation is essentially a for loop.</span>

<span class="sd">    If `otypes` is not specified, then a call to the function with the</span>
<span class="sd">    first argument will be used to determine the number of outputs.  The</span>
<span class="sd">    results of this call will be cached if `cache` is `True` to prevent</span>
<span class="sd">    calling the function twice.  However, to implement the cache, the</span>
<span class="sd">    original function must be wrapped which will slow down subsequent</span>
<span class="sd">    calls, so only do this if your function is expensive.</span>

<span class="sd">    The new keyword argument interface and `excluded` argument support</span>
<span class="sd">    further degrades performance.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pyfunc</span><span class="p">,</span> <span class="n">otypes</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">excluded</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">cache</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pyfunc</span> <span class="o">=</span> <span class="n">pyfunc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="o">=</span> <span class="n">cache</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ufunc</span> <span class="o">=</span> <span class="bp">None</span>    <span class="c1"># Caching to improve default performance</span>

        <span class="k">if</span> <span class="n">doc</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">pyfunc</span><span class="o">.</span><span class="n">__doc__</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">doc</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">otypes</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">otypes</span> <span class="o">=</span> <span class="n">otypes</span>
            <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">otypes</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">char</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">typecodes</span><span class="p">[</span><span class="s1">&#39;All&#39;</span><span class="p">]:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Invalid otype specified: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">char</span><span class="p">,))</span>
        <span class="k">elif</span> <span class="n">iterable</span><span class="p">(</span><span class="n">otypes</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">otypes</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">_nx</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">char</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">otypes</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Invalid otype specification&quot;</span><span class="p">)</span>

        <span class="c1"># Excluded variable support</span>
        <span class="k">if</span> <span class="n">excluded</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">excluded</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">excluded</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">excluded</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return arrays with the results of `pyfunc` broadcast (vectorized) over</span>
<span class="sd">        `args` and `kwargs` not in `excluded`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">excluded</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">excluded</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">excluded</span><span class="p">:</span>
            <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pyfunc</span>
            <span class="n">vargs</span> <span class="o">=</span> <span class="n">args</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># The wrapper accepts only positional arguments: we use `names` and</span>
            <span class="c1"># `inds` to mutate `the_args` and `kwargs` to pass to the original</span>
            <span class="c1"># function.</span>
            <span class="n">nargs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

            <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">_n</span> <span class="k">for</span> <span class="n">_n</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">if</span> <span class="n">_n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">excluded</span><span class="p">]</span>
            <span class="n">inds</span> <span class="o">=</span> <span class="p">[</span><span class="n">_i</span> <span class="k">for</span> <span class="n">_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nargs</span><span class="p">)</span> <span class="k">if</span> <span class="n">_i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">excluded</span><span class="p">]</span>
            <span class="n">the_args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="o">*</span><span class="n">vargs</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">_n</span><span class="p">,</span> <span class="n">_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inds</span><span class="p">):</span>
                    <span class="n">the_args</span><span class="p">[</span><span class="n">_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">vargs</span><span class="p">[</span><span class="n">_n</span><span class="p">]</span>
                <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">vargs</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">inds</span><span class="p">):]))</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pyfunc</span><span class="p">(</span><span class="o">*</span><span class="n">the_args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="n">vargs</span> <span class="o">=</span> <span class="p">[</span><span class="n">args</span><span class="p">[</span><span class="n">_i</span><span class="p">]</span> <span class="k">for</span> <span class="n">_i</span> <span class="ow">in</span> <span class="n">inds</span><span class="p">]</span>
            <span class="n">vargs</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">kwargs</span><span class="p">[</span><span class="n">_n</span><span class="p">]</span> <span class="k">for</span> <span class="n">_n</span> <span class="ow">in</span> <span class="n">names</span><span class="p">])</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vectorize_call</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="n">vargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_ufunc_and_otypes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return (ufunc, otypes).&quot;&quot;&quot;</span>
        <span class="c1"># frompyfunc will fail if args is empty</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;args can not be empty&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">otypes</span><span class="p">:</span>
            <span class="n">otypes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">otypes</span>
            <span class="n">nout</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">otypes</span><span class="p">)</span>

            <span class="c1"># Note logic here: We only *use* self._ufunc if func is self.pyfunc</span>
            <span class="c1"># even though we set self._ufunc regardless.</span>
            <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">pyfunc</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ufunc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">ufunc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ufunc</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ufunc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ufunc</span> <span class="o">=</span> <span class="n">frompyfunc</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">),</span> <span class="n">nout</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Get number of outputs and output types by calling the function on</span>
            <span class="c1"># the first entries of args.  We also cache the result to prevent</span>
            <span class="c1"># the subsequent call when the ufunc is evaluated.</span>
            <span class="c1"># Assumes that ufunc first evaluates the 0th elements in the input</span>
            <span class="c1"># arrays (the input values are not checked to ensure this)</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">asarray</span><span class="p">(</span><span class="n">_a</span><span class="p">)</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">_a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">inputs</span><span class="p">)</span>

            <span class="c1"># Performance note: profiling indicates that -- for simple</span>
            <span class="c1"># functions at least -- this wrapping can almost double the</span>
            <span class="c1"># execution time.</span>
            <span class="c1"># Hence we make it optional.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">:</span>
                <span class="n">_cache</span> <span class="o">=</span> <span class="p">[</span><span class="n">outputs</span><span class="p">]</span>

                <span class="k">def</span> <span class="nf">_func</span><span class="p">(</span><span class="o">*</span><span class="n">vargs</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">_cache</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">_cache</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">vargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_func</span> <span class="o">=</span> <span class="n">func</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="n">nout</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nout</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">outputs</span> <span class="o">=</span> <span class="p">(</span><span class="n">outputs</span><span class="p">,)</span>

            <span class="n">otypes</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">asarray</span><span class="p">(</span><span class="n">outputs</span><span class="p">[</span><span class="n">_k</span><span class="p">])</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">char</span>
                              <span class="k">for</span> <span class="n">_k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nout</span><span class="p">)])</span>

            <span class="c1"># Performance note: profiling indicates that creating the ufunc is</span>
            <span class="c1"># not a significant cost compared with wrapping so it seems not</span>
            <span class="c1"># worth trying to cache this.</span>
            <span class="n">ufunc</span> <span class="o">=</span> <span class="n">frompyfunc</span><span class="p">(</span><span class="n">_func</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">),</span> <span class="n">nout</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ufunc</span><span class="p">,</span> <span class="n">otypes</span>

    <span class="k">def</span> <span class="nf">_vectorize_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Vectorized call to `func` over positional `args`.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">_res</span> <span class="o">=</span> <span class="n">func</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ufunc</span><span class="p">,</span> <span class="n">otypes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_ufunc_and_otypes</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">)</span>

            <span class="c1"># Convert args to object arrays first</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">array</span><span class="p">(</span><span class="n">_a</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
                      <span class="k">for</span> <span class="n">_a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>

            <span class="n">outputs</span> <span class="o">=</span> <span class="n">ufunc</span><span class="p">(</span><span class="o">*</span><span class="n">inputs</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">ufunc</span><span class="o">.</span><span class="n">nout</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">_res</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span>
                             <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">otypes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_res</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">array</span><span class="p">(</span><span class="n">_x</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">_t</span><span class="p">)</span>
                              <span class="k">for</span> <span class="n">_x</span><span class="p">,</span> <span class="n">_t</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="n">otypes</span><span class="p">)])</span>
        <span class="k">return</span> <span class="n">_res</span>


<span class="k">def</span> <span class="nf">cov</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">rowvar</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">fweights</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">aweights</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Estimate a covariance matrix, given data and weights.</span>

<span class="sd">    Covariance indicates the level to which two variables vary together.</span>
<span class="sd">    If we examine N-dimensional samples, :math:`X = [x_1, x_2, ... x_N]^T`,</span>
<span class="sd">    then the covariance matrix element :math:`C_{ij}` is the covariance of</span>
<span class="sd">    :math:`x_i` and :math:`x_j`. The element :math:`C_{ii}` is the variance</span>
<span class="sd">    of :math:`x_i`.</span>

<span class="sd">    See the notes for an outline of the algorithm.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    m : array_like</span>
<span class="sd">        A 1-D or 2-D array containing multiple variables and observations.</span>
<span class="sd">        Each row of `m` represents a variable, and each column a single</span>
<span class="sd">        observation of all those variables. Also see `rowvar` below.</span>
<span class="sd">    y : array_like, optional</span>
<span class="sd">        An additional set of variables and observations. `y` has the same form</span>
<span class="sd">        as that of `m`.</span>
<span class="sd">    rowvar : int, optional</span>
<span class="sd">        If `rowvar` is non-zero (default), then each row represents a</span>
<span class="sd">        variable, with observations in the columns. Otherwise, the relationship</span>
<span class="sd">        is transposed: each column represents a variable, while the rows</span>
<span class="sd">        contain observations.</span>
<span class="sd">    bias : int, optional</span>
<span class="sd">        Default normalization is by ``(N - 1)``, where ``N`` corresponds to the</span>
<span class="sd">        number of observations given (unbiased estimate). If `bias` is 1, then</span>
<span class="sd">        normalization is by ``N``. These values can be overridden by using the</span>
<span class="sd">        keyword ``ddof`` in numpy versions &gt;= 1.5.</span>
<span class="sd">    ddof : int, optional</span>
<span class="sd">        If not ``None`` the default value implied by `bias` is overridden.</span>
<span class="sd">        Note that ``ddof=1`` will return the unbiased estimate, even if both</span>
<span class="sd">        `fweights` and `aweights` are specified, and ``ddof=0`` will return</span>
<span class="sd">        the simple average. See the notes for the details. The default value</span>
<span class="sd">        is ``None``.</span>

<span class="sd">        .. versionadded:: 1.5</span>
<span class="sd">    fweights : array_like, int, optional</span>
<span class="sd">        1-D array of integer freguency weights; the number of times each</span>
<span class="sd">        observation vector should be repeated.</span>

<span class="sd">        .. versionadded:: 1.10</span>
<span class="sd">    aweights : array_like, optional</span>
<span class="sd">        1-D array of observation vector weights. These relative weights are</span>
<span class="sd">        typically large for observations considered &quot;important&quot; and smaller for</span>
<span class="sd">        observations considered less &quot;important&quot;. If ``ddof=0`` the array of</span>
<span class="sd">        weights can be used to assign probabilities to observation vectors.</span>

<span class="sd">        .. versionadded:: 1.10</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray</span>
<span class="sd">        The covariance matrix of the variables.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    corrcoef : Normalized covariance matrix</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Assume that the observations are in the columns of the observation</span>
<span class="sd">    array `m` and let ``f = fweights`` and ``a = aweights`` for brevity. The</span>
<span class="sd">    steps to compute the weighted covariance are as follows::</span>

<span class="sd">        &gt;&gt;&gt; w = f * a</span>
<span class="sd">        &gt;&gt;&gt; v1 = np.sum(w)</span>
<span class="sd">        &gt;&gt;&gt; v2 = np.sum(w * a)</span>
<span class="sd">        &gt;&gt;&gt; m -= np.sum(m * w, axis=1, keepdims=True) / v1</span>
<span class="sd">        &gt;&gt;&gt; cov = np.dot(m * w, m.T) * v1 / (v1**2 - ddof * v2)</span>

<span class="sd">    Note that when ``a == 1``, the normalization factor</span>
<span class="sd">    ``v1 / (v1**2 - ddof * v2)`` goes over to ``1 / (np.sum(f) - ddof)``</span>
<span class="sd">    as it should.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Consider two variables, :math:`x_0` and :math:`x_1`, which</span>
<span class="sd">    correlate perfectly, but in opposite directions:</span>

<span class="sd">    &gt;&gt;&gt; x = np.array([[0, 2], [1, 1], [2, 0]]).T</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([[0, 1, 2],</span>
<span class="sd">           [2, 1, 0]])</span>

<span class="sd">    Note how :math:`x_0` increases while :math:`x_1` decreases. The covariance</span>
<span class="sd">    matrix shows this clearly:</span>

<span class="sd">    &gt;&gt;&gt; np.cov(x)</span>
<span class="sd">    array([[ 1., -1.],</span>
<span class="sd">           [-1.,  1.]])</span>

<span class="sd">    Note that element :math:`C_{0,1}`, which shows the correlation between</span>
<span class="sd">    :math:`x_0` and :math:`x_1`, is negative.</span>

<span class="sd">    Further, note how `x` and `y` are combined:</span>

<span class="sd">    &gt;&gt;&gt; x = [-2.1, -1,  4.3]</span>
<span class="sd">    &gt;&gt;&gt; y = [3,  1.1,  0.12]</span>
<span class="sd">    &gt;&gt;&gt; X = np.vstack((x,y))</span>
<span class="sd">    &gt;&gt;&gt; print np.cov(X)</span>
<span class="sd">    [[ 11.71        -4.286     ]</span>
<span class="sd">     [ -4.286        2.14413333]]</span>
<span class="sd">    &gt;&gt;&gt; print np.cov(x, y)</span>
<span class="sd">    [[ 11.71        -4.286     ]</span>
<span class="sd">     [ -4.286        2.14413333]]</span>
<span class="sd">    &gt;&gt;&gt; print np.cov(x)</span>
<span class="sd">    11.71</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check inputs</span>
    <span class="k">if</span> <span class="n">ddof</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">ddof</span> <span class="o">!=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ddof</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;ddof must be integer&quot;</span><span class="p">)</span>

    <span class="c1"># Handles complex arrays too</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rowvar</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span>
    <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rowvar</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">T</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">ddof</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">bias</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ddof</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ddof</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Get the product of frequencies and weights</span>
    <span class="n">w</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="n">fweights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">fweights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">fweights</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">fweights</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">fweights</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;fweights must be integer&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fweights</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;cannot handle multidimensional fweights&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fweights</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;incompatible numbers of samples and fweights&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">fweights</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;fweights cannot be negative&quot;</span><span class="p">)</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">fweights</span>
    <span class="k">if</span> <span class="n">aweights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">aweights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">aweights</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">aweights</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;cannot handle multidimensional aweights&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">aweights</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;incompatible numbers of samples and aweights&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">aweights</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;aweights cannot be negative&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">aweights</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">*=</span> <span class="n">aweights</span>

    <span class="n">avg</span><span class="p">,</span> <span class="n">w_sum</span> <span class="o">=</span> <span class="n">average</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="n">returned</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">w_sum</span> <span class="o">=</span> <span class="n">w_sum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Determine the normalization</span>
    <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">fact</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ddof</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">ddof</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">fact</span> <span class="o">=</span> <span class="n">w_sum</span>
    <span class="k">elif</span> <span class="n">aweights</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">fact</span> <span class="o">=</span> <span class="n">w_sum</span> <span class="o">-</span> <span class="n">ddof</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fact</span> <span class="o">=</span> <span class="n">w_sum</span> <span class="o">-</span> <span class="n">ddof</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">aweights</span><span class="p">)</span><span class="o">/</span><span class="n">w_sum</span>

    <span class="k">if</span> <span class="n">fact</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Degrees of freedom &lt;= 0 for slice&quot;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>
        <span class="n">fact</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="n">X</span> <span class="o">-=</span> <span class="n">avg</span><span class="p">[:,</span> <span class="bp">None</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">X_T</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">X_T</span> <span class="o">=</span> <span class="p">(</span><span class="n">X</span><span class="o">*</span><span class="n">w</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">X_T</span><span class="o">.</span><span class="n">conj</span><span class="p">())</span><span class="o">/</span><span class="n">fact</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">corrcoef</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">rowvar</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return Pearson product-moment correlation coefficients.</span>

<span class="sd">    Please refer to the documentation for `cov` for more detail.  The</span>
<span class="sd">    relationship between the correlation coefficient matrix, `R`, and the</span>
<span class="sd">    covariance matrix, `C`, is</span>

<span class="sd">    .. math:: R_{ij} = \\frac{ C_{ij} } { \\sqrt{ C_{ii} * C_{jj} } }</span>

<span class="sd">    The values of `R` are between -1 and 1, inclusive.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like</span>
<span class="sd">        A 1-D or 2-D array containing multiple variables and observations.</span>
<span class="sd">        Each row of `x` represents a variable, and each column a single</span>
<span class="sd">        observation of all those variables. Also see `rowvar` below.</span>
<span class="sd">    y : array_like, optional</span>
<span class="sd">        An additional set of variables and observations. `y` has the same</span>
<span class="sd">        shape as `x`.</span>
<span class="sd">    rowvar : int, optional</span>
<span class="sd">        If `rowvar` is non-zero (default), then each row represents a</span>
<span class="sd">        variable, with observations in the columns. Otherwise, the relationship</span>
<span class="sd">        is transposed: each column represents a variable, while the rows</span>
<span class="sd">        contain observations.</span>
<span class="sd">    bias : _NoValue, optional</span>
<span class="sd">        Has no affect, do not use.</span>

<span class="sd">        .. deprecated:: 1.10.0</span>
<span class="sd">    ddof : _NoValue, optional</span>
<span class="sd">        Has no affect, do not use.</span>

<span class="sd">        .. deprecated:: 1.10.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    R : ndarray</span>
<span class="sd">        The correlation coefficient matrix of the variables.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    cov : Covariance matrix</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function accepts but discards arguments `bias` and `ddof`.  This is</span>
<span class="sd">    for backwards compatibility with previous versions of this function.  These</span>
<span class="sd">    arguments had no effect on the return values of the function and can be</span>
<span class="sd">    safely ignored in this and previous versions of numpy.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">bias</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span> <span class="ow">or</span> <span class="n">ddof</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">:</span>
        <span class="c1"># 2015-03-15, 1.10</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;bias and ddof have no affect and are deprecated&#39;</span><span class="p">,</span>
                      <span class="ne">DeprecationWarning</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">cov</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">rowvar</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">diag</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>  <span class="c1"># scalar covariance</span>
        <span class="c1"># nan if incorrect value (nan, inf, 0), 1 otherwise</span>
        <span class="k">return</span> <span class="n">c</span> <span class="o">/</span> <span class="n">c</span>
    <span class="k">return</span> <span class="n">c</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">multiply</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">blackman</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the Blackman window.</span>

<span class="sd">    The Blackman window is a taper formed by using the first three</span>
<span class="sd">    terms of a summation of cosines. It was designed to have close to the</span>
<span class="sd">    minimal leakage possible.  It is close to optimal, only slightly worse</span>
<span class="sd">    than a Kaiser window.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    M : int</span>
<span class="sd">        Number of points in the output window. If zero or less, an empty</span>
<span class="sd">        array is returned.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray</span>
<span class="sd">        The window, with the maximum value normalized to one (the value one</span>
<span class="sd">        appears only if the number of samples is odd).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    bartlett, hamming, hanning, kaiser</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The Blackman window is defined as</span>

<span class="sd">    .. math::  w(n) = 0.42 - 0.5 \\cos(2\\pi n/M) + 0.08 \\cos(4\\pi n/M)</span>

<span class="sd">    Most references to the Blackman window come from the signal processing</span>
<span class="sd">    literature, where it is used as one of many windowing functions for</span>
<span class="sd">    smoothing values.  It is also known as an apodization (which means</span>
<span class="sd">    &quot;removing the foot&quot;, i.e. smoothing discontinuities at the beginning</span>
<span class="sd">    and end of the sampled signal) or tapering function. It is known as a</span>
<span class="sd">    &quot;near optimal&quot; tapering function, almost as good (by some measures)</span>
<span class="sd">    as the kaiser window.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    Blackman, R.B. and Tukey, J.W., (1958) The measurement of power spectra,</span>
<span class="sd">    Dover Publications, New York.</span>

<span class="sd">    Oppenheim, A.V., and R.W. Schafer. Discrete-Time Signal Processing.</span>
<span class="sd">    Upper Saddle River, NJ: Prentice-Hall, 1999, pp. 468-471.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.blackman(12)</span>
<span class="sd">    array([ -1.38777878e-17,   3.26064346e-02,   1.59903635e-01,</span>
<span class="sd">             4.14397981e-01,   7.36045180e-01,   9.67046769e-01,</span>
<span class="sd">             9.67046769e-01,   7.36045180e-01,   4.14397981e-01,</span>
<span class="sd">             1.59903635e-01,   3.26064346e-02,  -1.38777878e-17])</span>


<span class="sd">    Plot the window and the frequency response:</span>

<span class="sd">    &gt;&gt;&gt; from numpy.fft import fft, fftshift</span>
<span class="sd">    &gt;&gt;&gt; window = np.blackman(51)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(window)</span>
<span class="sd">    [&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&quot;Blackman window&quot;)</span>
<span class="sd">    &lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&quot;Amplitude&quot;)</span>
<span class="sd">    &lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&quot;Sample&quot;)</span>
<span class="sd">    &lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &gt;&gt;&gt; plt.figure()</span>
<span class="sd">    &lt;matplotlib.figure.Figure object at 0x...&gt;</span>
<span class="sd">    &gt;&gt;&gt; A = fft(window, 2048) / 25.5</span>
<span class="sd">    &gt;&gt;&gt; mag = np.abs(fftshift(A))</span>
<span class="sd">    &gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A))</span>
<span class="sd">    &gt;&gt;&gt; response = 20 * np.log10(mag)</span>
<span class="sd">    &gt;&gt;&gt; response = np.clip(response, -100, 100)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(freq, response)</span>
<span class="sd">    [&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&quot;Frequency response of Blackman window&quot;)</span>
<span class="sd">    &lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&quot;Magnitude [dB]&quot;)</span>
<span class="sd">    &lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&quot;Normalized frequency [cycles per sample]&quot;)</span>
<span class="sd">    &lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="sd">    &gt;&gt;&gt; plt.axis(&#39;tight&#39;)</span>
<span class="sd">    (-0.5, 0.5, -100.0, ...)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">M</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">array</span><span class="p">([])</span>
    <span class="k">if</span> <span class="n">M</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
    <span class="k">return</span> <span class="mf">0.42</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">n</span><span class="o">/</span><span class="p">(</span><span class="n">M</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="mf">0.08</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="mf">4.0</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">n</span><span class="o">/</span><span class="p">(</span><span class="n">M</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">bartlett</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the Bartlett window.</span>

<span class="sd">    The Bartlett window is very similar to a triangular window, except</span>
<span class="sd">    that the end points are at zero.  It is often used in signal</span>
<span class="sd">    processing for tapering a signal, without generating too much</span>
<span class="sd">    ripple in the frequency domain.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    M : int</span>
<span class="sd">        Number of points in the output window. If zero or less, an</span>
<span class="sd">        empty array is returned.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : array</span>
<span class="sd">        The triangular window, with the maximum value normalized to one</span>
<span class="sd">        (the value one appears only if the number of samples is odd), with</span>
<span class="sd">        the first and last samples equal to zero.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    blackman, hamming, hanning, kaiser</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The Bartlett window is defined as</span>

<span class="sd">    .. math:: w(n) = \\frac{2}{M-1} \\left(</span>
<span class="sd">              \\frac{M-1}{2} - \\left|n - \\frac{M-1}{2}\\right|</span>
<span class="sd">              \\right)</span>

<span class="sd">    Most references to the Bartlett window come from the signal</span>
<span class="sd">    processing literature, where it is used as one of many windowing</span>
<span class="sd">    functions for smoothing values.  Note that convolution with this</span>
<span class="sd">    window produces linear interpolation.  It is also known as an</span>
<span class="sd">    apodization (which means&quot;removing the foot&quot;, i.e. smoothing</span>
<span class="sd">    discontinuities at the beginning and end of the sampled signal) or</span>
<span class="sd">    tapering function. The fourier transform of the Bartlett is the product</span>
<span class="sd">    of two sinc functions.</span>
<span class="sd">    Note the excellent discussion in Kanasewich.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] M.S. Bartlett, &quot;Periodogram Analysis and Continuous Spectra&quot;,</span>
<span class="sd">           Biometrika 37, 1-16, 1950.</span>
<span class="sd">    .. [2] E.R. Kanasewich, &quot;Time Sequence Analysis in Geophysics&quot;,</span>
<span class="sd">           The University of Alberta Press, 1975, pp. 109-110.</span>
<span class="sd">    .. [3] A.V. Oppenheim and R.W. Schafer, &quot;Discrete-Time Signal</span>
<span class="sd">           Processing&quot;, Prentice-Hall, 1999, pp. 468-471.</span>
<span class="sd">    .. [4] Wikipedia, &quot;Window function&quot;,</span>
<span class="sd">           http://en.wikipedia.org/wiki/Window_function</span>
<span class="sd">    .. [5] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,</span>
<span class="sd">           &quot;Numerical Recipes&quot;, Cambridge University Press, 1986, page 429.</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.bartlett(12)</span>
<span class="sd">    array([ 0.        ,  0.18181818,  0.36363636,  0.54545455,  0.72727273,</span>
<span class="sd">            0.90909091,  0.90909091,  0.72727273,  0.54545455,  0.36363636,</span>
<span class="sd">            0.18181818,  0.        ])</span>

<span class="sd">    Plot the window and its frequency response (requires SciPy and matplotlib):</span>

<span class="sd">    &gt;&gt;&gt; from numpy.fft import fft, fftshift</span>
<span class="sd">    &gt;&gt;&gt; window = np.bartlett(51)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(window)</span>
<span class="sd">    [&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&quot;Bartlett window&quot;)</span>
<span class="sd">    &lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&quot;Amplitude&quot;)</span>
<span class="sd">    &lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&quot;Sample&quot;)</span>
<span class="sd">    &lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &gt;&gt;&gt; plt.figure()</span>
<span class="sd">    &lt;matplotlib.figure.Figure object at 0x...&gt;</span>
<span class="sd">    &gt;&gt;&gt; A = fft(window, 2048) / 25.5</span>
<span class="sd">    &gt;&gt;&gt; mag = np.abs(fftshift(A))</span>
<span class="sd">    &gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A))</span>
<span class="sd">    &gt;&gt;&gt; response = 20 * np.log10(mag)</span>
<span class="sd">    &gt;&gt;&gt; response = np.clip(response, -100, 100)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(freq, response)</span>
<span class="sd">    [&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&quot;Frequency response of Bartlett window&quot;)</span>
<span class="sd">    &lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&quot;Magnitude [dB]&quot;)</span>
<span class="sd">    &lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&quot;Normalized frequency [cycles per sample]&quot;)</span>
<span class="sd">    &lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="sd">    &gt;&gt;&gt; plt.axis(&#39;tight&#39;)</span>
<span class="sd">    (-0.5, 0.5, -100.0, ...)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">M</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">array</span><span class="p">([])</span>
    <span class="k">if</span> <span class="n">M</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">where</span><span class="p">(</span><span class="n">less_equal</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="n">M</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span><span class="p">),</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">n</span><span class="o">/</span><span class="p">(</span><span class="n">M</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">n</span><span class="o">/</span><span class="p">(</span><span class="n">M</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">hanning</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the Hanning window.</span>

<span class="sd">    The Hanning window is a taper formed by using a weighted cosine.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    M : int</span>
<span class="sd">        Number of points in the output window. If zero or less, an</span>
<span class="sd">        empty array is returned.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray, shape(M,)</span>
<span class="sd">        The window, with the maximum value normalized to one (the value</span>
<span class="sd">        one appears only if `M` is odd).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    bartlett, blackman, hamming, kaiser</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The Hanning window is defined as</span>

<span class="sd">    .. math::  w(n) = 0.5 - 0.5cos\\left(\\frac{2\\pi{n}}{M-1}\\right)</span>
<span class="sd">               \\qquad 0 \\leq n \\leq M-1</span>

<span class="sd">    The Hanning was named for Julius von Hann, an Austrian meteorologist.</span>
<span class="sd">    It is also known as the Cosine Bell. Some authors prefer that it be</span>
<span class="sd">    called a Hann window, to help avoid confusion with the very similar</span>
<span class="sd">    Hamming window.</span>

<span class="sd">    Most references to the Hanning window come from the signal processing</span>
<span class="sd">    literature, where it is used as one of many windowing functions for</span>
<span class="sd">    smoothing values.  It is also known as an apodization (which means</span>
<span class="sd">    &quot;removing the foot&quot;, i.e. smoothing discontinuities at the beginning</span>
<span class="sd">    and end of the sampled signal) or tapering function.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Blackman, R.B. and Tukey, J.W., (1958) The measurement of power</span>
<span class="sd">           spectra, Dover Publications, New York.</span>
<span class="sd">    .. [2] E.R. Kanasewich, &quot;Time Sequence Analysis in Geophysics&quot;,</span>
<span class="sd">           The University of Alberta Press, 1975, pp. 106-108.</span>
<span class="sd">    .. [3] Wikipedia, &quot;Window function&quot;,</span>
<span class="sd">           http://en.wikipedia.org/wiki/Window_function</span>
<span class="sd">    .. [4] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,</span>
<span class="sd">           &quot;Numerical Recipes&quot;, Cambridge University Press, 1986, page 425.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.hanning(12)</span>
<span class="sd">    array([ 0.        ,  0.07937323,  0.29229249,  0.57115742,  0.82743037,</span>
<span class="sd">            0.97974649,  0.97974649,  0.82743037,  0.57115742,  0.29229249,</span>
<span class="sd">            0.07937323,  0.        ])</span>

<span class="sd">    Plot the window and its frequency response:</span>

<span class="sd">    &gt;&gt;&gt; from numpy.fft import fft, fftshift</span>
<span class="sd">    &gt;&gt;&gt; window = np.hanning(51)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(window)</span>
<span class="sd">    [&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&quot;Hann window&quot;)</span>
<span class="sd">    &lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&quot;Amplitude&quot;)</span>
<span class="sd">    &lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&quot;Sample&quot;)</span>
<span class="sd">    &lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &gt;&gt;&gt; plt.figure()</span>
<span class="sd">    &lt;matplotlib.figure.Figure object at 0x...&gt;</span>
<span class="sd">    &gt;&gt;&gt; A = fft(window, 2048) / 25.5</span>
<span class="sd">    &gt;&gt;&gt; mag = np.abs(fftshift(A))</span>
<span class="sd">    &gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A))</span>
<span class="sd">    &gt;&gt;&gt; response = 20 * np.log10(mag)</span>
<span class="sd">    &gt;&gt;&gt; response = np.clip(response, -100, 100)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(freq, response)</span>
<span class="sd">    [&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&quot;Frequency response of the Hann window&quot;)</span>
<span class="sd">    &lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&quot;Magnitude [dB]&quot;)</span>
<span class="sd">    &lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&quot;Normalized frequency [cycles per sample]&quot;)</span>
<span class="sd">    &lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="sd">    &gt;&gt;&gt; plt.axis(&#39;tight&#39;)</span>
<span class="sd">    (-0.5, 0.5, -100.0, ...)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">M</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">array</span><span class="p">([])</span>
    <span class="k">if</span> <span class="n">M</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
    <span class="k">return</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">n</span><span class="o">/</span><span class="p">(</span><span class="n">M</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">hamming</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the Hamming window.</span>

<span class="sd">    The Hamming window is a taper formed by using a weighted cosine.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    M : int</span>
<span class="sd">        Number of points in the output window. If zero or less, an</span>
<span class="sd">        empty array is returned.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray</span>
<span class="sd">        The window, with the maximum value normalized to one (the value</span>
<span class="sd">        one appears only if the number of samples is odd).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    bartlett, blackman, hanning, kaiser</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The Hamming window is defined as</span>

<span class="sd">    .. math::  w(n) = 0.54 - 0.46cos\\left(\\frac{2\\pi{n}}{M-1}\\right)</span>
<span class="sd">               \\qquad 0 \\leq n \\leq M-1</span>

<span class="sd">    The Hamming was named for R. W. Hamming, an associate of J. W. Tukey</span>
<span class="sd">    and is described in Blackman and Tukey. It was recommended for</span>
<span class="sd">    smoothing the truncated autocovariance function in the time domain.</span>
<span class="sd">    Most references to the Hamming window come from the signal processing</span>
<span class="sd">    literature, where it is used as one of many windowing functions for</span>
<span class="sd">    smoothing values.  It is also known as an apodization (which means</span>
<span class="sd">    &quot;removing the foot&quot;, i.e. smoothing discontinuities at the beginning</span>
<span class="sd">    and end of the sampled signal) or tapering function.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Blackman, R.B. and Tukey, J.W., (1958) The measurement of power</span>
<span class="sd">           spectra, Dover Publications, New York.</span>
<span class="sd">    .. [2] E.R. Kanasewich, &quot;Time Sequence Analysis in Geophysics&quot;, The</span>
<span class="sd">           University of Alberta Press, 1975, pp. 109-110.</span>
<span class="sd">    .. [3] Wikipedia, &quot;Window function&quot;,</span>
<span class="sd">           http://en.wikipedia.org/wiki/Window_function</span>
<span class="sd">    .. [4] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,</span>
<span class="sd">           &quot;Numerical Recipes&quot;, Cambridge University Press, 1986, page 425.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.hamming(12)</span>
<span class="sd">    array([ 0.08      ,  0.15302337,  0.34890909,  0.60546483,  0.84123594,</span>
<span class="sd">            0.98136677,  0.98136677,  0.84123594,  0.60546483,  0.34890909,</span>
<span class="sd">            0.15302337,  0.08      ])</span>

<span class="sd">    Plot the window and the frequency response:</span>

<span class="sd">    &gt;&gt;&gt; from numpy.fft import fft, fftshift</span>
<span class="sd">    &gt;&gt;&gt; window = np.hamming(51)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(window)</span>
<span class="sd">    [&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&quot;Hamming window&quot;)</span>
<span class="sd">    &lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&quot;Amplitude&quot;)</span>
<span class="sd">    &lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&quot;Sample&quot;)</span>
<span class="sd">    &lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &gt;&gt;&gt; plt.figure()</span>
<span class="sd">    &lt;matplotlib.figure.Figure object at 0x...&gt;</span>
<span class="sd">    &gt;&gt;&gt; A = fft(window, 2048) / 25.5</span>
<span class="sd">    &gt;&gt;&gt; mag = np.abs(fftshift(A))</span>
<span class="sd">    &gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A))</span>
<span class="sd">    &gt;&gt;&gt; response = 20 * np.log10(mag)</span>
<span class="sd">    &gt;&gt;&gt; response = np.clip(response, -100, 100)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(freq, response)</span>
<span class="sd">    [&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&quot;Frequency response of Hamming window&quot;)</span>
<span class="sd">    &lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&quot;Magnitude [dB]&quot;)</span>
<span class="sd">    &lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&quot;Normalized frequency [cycles per sample]&quot;)</span>
<span class="sd">    &lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="sd">    &gt;&gt;&gt; plt.axis(&#39;tight&#39;)</span>
<span class="sd">    (-0.5, 0.5, -100.0, ...)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">M</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">array</span><span class="p">([])</span>
    <span class="k">if</span> <span class="n">M</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
    <span class="k">return</span> <span class="mf">0.54</span> <span class="o">-</span> <span class="mf">0.46</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">n</span><span class="o">/</span><span class="p">(</span><span class="n">M</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>

<span class="c1">## Code from cephes for i0</span>

<span class="n">_i0A</span> <span class="o">=</span> <span class="p">[</span>
    <span class="o">-</span><span class="mf">4.41534164647933937950E-18</span><span class="p">,</span>
    <span class="mf">3.33079451882223809783E-17</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">2.43127984654795469359E-16</span><span class="p">,</span>
    <span class="mf">1.71539128555513303061E-15</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">1.16853328779934516808E-14</span><span class="p">,</span>
    <span class="mf">7.67618549860493561688E-14</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">4.85644678311192946090E-13</span><span class="p">,</span>
    <span class="mf">2.95505266312963983461E-12</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">1.72682629144155570723E-11</span><span class="p">,</span>
    <span class="mf">9.67580903537323691224E-11</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">5.18979560163526290666E-10</span><span class="p">,</span>
    <span class="mf">2.65982372468238665035E-9</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">1.30002500998624804212E-8</span><span class="p">,</span>
    <span class="mf">6.04699502254191894932E-8</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">2.67079385394061173391E-7</span><span class="p">,</span>
    <span class="mf">1.11738753912010371815E-6</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">4.41673835845875056359E-6</span><span class="p">,</span>
    <span class="mf">1.64484480707288970893E-5</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">5.75419501008210370398E-5</span><span class="p">,</span>
    <span class="mf">1.88502885095841655729E-4</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">5.76375574538582365885E-4</span><span class="p">,</span>
    <span class="mf">1.63947561694133579842E-3</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">4.32430999505057594430E-3</span><span class="p">,</span>
    <span class="mf">1.05464603945949983183E-2</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">2.37374148058994688156E-2</span><span class="p">,</span>
    <span class="mf">4.93052842396707084878E-2</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">9.49010970480476444210E-2</span><span class="p">,</span>
    <span class="mf">1.71620901522208775349E-1</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">3.04682672343198398683E-1</span><span class="p">,</span>
    <span class="mf">6.76795274409476084995E-1</span>
    <span class="p">]</span>

<span class="n">_i0B</span> <span class="o">=</span> <span class="p">[</span>
    <span class="o">-</span><span class="mf">7.23318048787475395456E-18</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">4.83050448594418207126E-18</span><span class="p">,</span>
    <span class="mf">4.46562142029675999901E-17</span><span class="p">,</span>
    <span class="mf">3.46122286769746109310E-17</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">2.82762398051658348494E-16</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">3.42548561967721913462E-16</span><span class="p">,</span>
    <span class="mf">1.77256013305652638360E-15</span><span class="p">,</span>
    <span class="mf">3.81168066935262242075E-15</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">9.55484669882830764870E-15</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">4.15056934728722208663E-14</span><span class="p">,</span>
    <span class="mf">1.54008621752140982691E-14</span><span class="p">,</span>
    <span class="mf">3.85277838274214270114E-13</span><span class="p">,</span>
    <span class="mf">7.18012445138366623367E-13</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">1.79417853150680611778E-12</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">1.32158118404477131188E-11</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">3.14991652796324136454E-11</span><span class="p">,</span>
    <span class="mf">1.18891471078464383424E-11</span><span class="p">,</span>
    <span class="mf">4.94060238822496958910E-10</span><span class="p">,</span>
    <span class="mf">3.39623202570838634515E-9</span><span class="p">,</span>
    <span class="mf">2.26666899049817806459E-8</span><span class="p">,</span>
    <span class="mf">2.04891858946906374183E-7</span><span class="p">,</span>
    <span class="mf">2.89137052083475648297E-6</span><span class="p">,</span>
    <span class="mf">6.88975834691682398426E-5</span><span class="p">,</span>
    <span class="mf">3.36911647825569408990E-3</span><span class="p">,</span>
    <span class="mf">8.04490411014108831608E-1</span>
    <span class="p">]</span>


<span class="k">def</span> <span class="nf">_chbevl</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">vals</span><span class="p">):</span>
    <span class="n">b0</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">b1</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">vals</span><span class="p">)):</span>
        <span class="n">b2</span> <span class="o">=</span> <span class="n">b1</span>
        <span class="n">b1</span> <span class="o">=</span> <span class="n">b0</span>
        <span class="n">b0</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="n">b1</span> <span class="o">-</span> <span class="n">b2</span> <span class="o">+</span> <span class="n">vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">return</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">b0</span> <span class="o">-</span> <span class="n">b2</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_i0_1</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">_chbevl</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="mf">2.0</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">_i0A</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_i0_2</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">_chbevl</span><span class="p">(</span><span class="mf">32.0</span><span class="o">/</span><span class="n">x</span> <span class="o">-</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">_i0B</span><span class="p">)</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">i0</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Modified Bessel function of the first kind, order 0.</span>

<span class="sd">    Usually denoted :math:`I_0`.  This function does broadcast, but will *not*</span>
<span class="sd">    &quot;up-cast&quot; int dtype arguments unless accompanied by at least one float or</span>
<span class="sd">    complex dtype argument (see Raises below).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like, dtype float or complex</span>
<span class="sd">        Argument of the Bessel function.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray, shape = x.shape, dtype = x.dtype</span>
<span class="sd">        The modified Bessel function evaluated at each of the elements of `x`.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    TypeError: array cannot be safely cast to required type</span>
<span class="sd">        If argument consists exclusively of int dtypes.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    scipy.special.iv, scipy.special.ive</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    We use the algorithm published by Clenshaw [1]_ and referenced by</span>
<span class="sd">    Abramowitz and Stegun [2]_, for which the function domain is</span>
<span class="sd">    partitioned into the two intervals [0,8] and (8,inf), and Chebyshev</span>
<span class="sd">    polynomial expansions are employed in each interval. Relative error on</span>
<span class="sd">    the domain [0,30] using IEEE arithmetic is documented [3]_ as having a</span>
<span class="sd">    peak of 5.8e-16 with an rms of 1.4e-16 (n = 30000).</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] C. W. Clenshaw, &quot;Chebyshev series for mathematical functions&quot;, in</span>
<span class="sd">           *National Physical Laboratory Mathematical Tables*, vol. 5, London:</span>
<span class="sd">           Her Majesty&#39;s Stationery Office, 1962.</span>
<span class="sd">    .. [2] M. Abramowitz and I. A. Stegun, *Handbook of Mathematical</span>
<span class="sd">           Functions*, 10th printing, New York: Dover, 1964, pp. 379.</span>
<span class="sd">           http://www.math.sfu.ca/~cbm/aands/page_379.htm</span>
<span class="sd">    .. [3] http://kobesearch.cpan.org/htdocs/Math-Cephes/Math/Cephes.html</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.i0([0.])</span>
<span class="sd">    array(1.0)</span>
<span class="sd">    &gt;&gt;&gt; np.i0([0., 1. + 2j])</span>
<span class="sd">    array([ 1.00000000+0.j        ,  0.18785373+0.64616944j])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">atleast_1d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">empty_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">ind</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">x</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
    <span class="n">ind</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="mf">8.0</span><span class="p">)</span>
    <span class="n">y</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">_i0_1</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span>
    <span class="n">ind2</span> <span class="o">=</span> <span class="o">~</span><span class="n">ind</span>
    <span class="n">y</span><span class="p">[</span><span class="n">ind2</span><span class="p">]</span> <span class="o">=</span> <span class="n">_i0_2</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">ind2</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">y</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

<span class="c1">## End of cephes code for i0</span>


<span class="k">def</span> <span class="nf">kaiser</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">beta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the Kaiser window.</span>

<span class="sd">    The Kaiser window is a taper formed by using a Bessel function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    M : int</span>
<span class="sd">        Number of points in the output window. If zero or less, an</span>
<span class="sd">        empty array is returned.</span>
<span class="sd">    beta : float</span>
<span class="sd">        Shape parameter for window.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : array</span>
<span class="sd">        The window, with the maximum value normalized to one (the value</span>
<span class="sd">        one appears only if the number of samples is odd).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    bartlett, blackman, hamming, hanning</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The Kaiser window is defined as</span>

<span class="sd">    .. math::  w(n) = I_0\\left( \\beta \\sqrt{1-\\frac{4n^2}{(M-1)^2}}</span>
<span class="sd">               \\right)/I_0(\\beta)</span>

<span class="sd">    with</span>

<span class="sd">    .. math:: \\quad -\\frac{M-1}{2} \\leq n \\leq \\frac{M-1}{2},</span>

<span class="sd">    where :math:`I_0` is the modified zeroth-order Bessel function.</span>

<span class="sd">    The Kaiser was named for Jim Kaiser, who discovered a simple</span>
<span class="sd">    approximation to the DPSS window based on Bessel functions.  The Kaiser</span>
<span class="sd">    window is a very good approximation to the Digital Prolate Spheroidal</span>
<span class="sd">    Sequence, or Slepian window, which is the transform which maximizes the</span>
<span class="sd">    energy in the main lobe of the window relative to total energy.</span>

<span class="sd">    The Kaiser can approximate many other windows by varying the beta</span>
<span class="sd">    parameter.</span>

<span class="sd">    ====  =======================</span>
<span class="sd">    beta  Window shape</span>
<span class="sd">    ====  =======================</span>
<span class="sd">    0     Rectangular</span>
<span class="sd">    5     Similar to a Hamming</span>
<span class="sd">    6     Similar to a Hanning</span>
<span class="sd">    8.6   Similar to a Blackman</span>
<span class="sd">    ====  =======================</span>

<span class="sd">    A beta value of 14 is probably a good starting point. Note that as beta</span>
<span class="sd">    gets large, the window narrows, and so the number of samples needs to be</span>
<span class="sd">    large enough to sample the increasingly narrow spike, otherwise NaNs will</span>
<span class="sd">    get returned.</span>

<span class="sd">    Most references to the Kaiser window come from the signal processing</span>
<span class="sd">    literature, where it is used as one of many windowing functions for</span>
<span class="sd">    smoothing values.  It is also known as an apodization (which means</span>
<span class="sd">    &quot;removing the foot&quot;, i.e. smoothing discontinuities at the beginning</span>
<span class="sd">    and end of the sampled signal) or tapering function.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] J. F. Kaiser, &quot;Digital Filters&quot; - Ch 7 in &quot;Systems analysis by</span>
<span class="sd">           digital computer&quot;, Editors: F.F. Kuo and J.F. Kaiser, p 218-285.</span>
<span class="sd">           John Wiley and Sons, New York, (1966).</span>
<span class="sd">    .. [2] E.R. Kanasewich, &quot;Time Sequence Analysis in Geophysics&quot;, The</span>
<span class="sd">           University of Alberta Press, 1975, pp. 177-178.</span>
<span class="sd">    .. [3] Wikipedia, &quot;Window function&quot;,</span>
<span class="sd">           http://en.wikipedia.org/wiki/Window_function</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.kaiser(12, 14)</span>
<span class="sd">    array([  7.72686684e-06,   3.46009194e-03,   4.65200189e-02,</span>
<span class="sd">             2.29737120e-01,   5.99885316e-01,   9.45674898e-01,</span>
<span class="sd">             9.45674898e-01,   5.99885316e-01,   2.29737120e-01,</span>
<span class="sd">             4.65200189e-02,   3.46009194e-03,   7.72686684e-06])</span>


<span class="sd">    Plot the window and the frequency response:</span>

<span class="sd">    &gt;&gt;&gt; from numpy.fft import fft, fftshift</span>
<span class="sd">    &gt;&gt;&gt; window = np.kaiser(51, 14)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(window)</span>
<span class="sd">    [&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&quot;Kaiser window&quot;)</span>
<span class="sd">    &lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&quot;Amplitude&quot;)</span>
<span class="sd">    &lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&quot;Sample&quot;)</span>
<span class="sd">    &lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &gt;&gt;&gt; plt.figure()</span>
<span class="sd">    &lt;matplotlib.figure.Figure object at 0x...&gt;</span>
<span class="sd">    &gt;&gt;&gt; A = fft(window, 2048) / 25.5</span>
<span class="sd">    &gt;&gt;&gt; mag = np.abs(fftshift(A))</span>
<span class="sd">    &gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A))</span>
<span class="sd">    &gt;&gt;&gt; response = 20 * np.log10(mag)</span>
<span class="sd">    &gt;&gt;&gt; response = np.clip(response, -100, 100)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(freq, response)</span>
<span class="sd">    [&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&quot;Frequency response of Kaiser window&quot;)</span>
<span class="sd">    &lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&quot;Magnitude [dB]&quot;)</span>
<span class="sd">    &lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&quot;Normalized frequency [cycles per sample]&quot;)</span>
<span class="sd">    &lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="sd">    &gt;&gt;&gt; plt.axis(&#39;tight&#39;)</span>
<span class="sd">    (-0.5, 0.5, -100.0, ...)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">numpy.dual</span> <span class="kn">import</span> <span class="n">i0</span>
    <span class="k">if</span> <span class="n">M</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">])</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="p">(</span><span class="n">M</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span>
    <span class="k">return</span> <span class="n">i0</span><span class="p">(</span><span class="n">beta</span> <span class="o">*</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="p">((</span><span class="n">n</span><span class="o">-</span><span class="n">alpha</span><span class="p">)</span><span class="o">/</span><span class="n">alpha</span><span class="p">)</span><span class="o">**</span><span class="mf">2.0</span><span class="p">))</span><span class="o">/</span><span class="n">i0</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">beta</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">sinc</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the sinc function.</span>

<span class="sd">    The sinc function is :math:`\\sin(\\pi x)/(\\pi x)`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : ndarray</span>
<span class="sd">        Array (possibly multi-dimensional) of values for which to to</span>
<span class="sd">        calculate ``sinc(x)``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray</span>
<span class="sd">        ``sinc(x)``, which has the same shape as the input.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    ``sinc(0)`` is the limit value 1.</span>

<span class="sd">    The name sinc is short for &quot;sine cardinal&quot; or &quot;sinus cardinalis&quot;.</span>

<span class="sd">    The sinc function is used in various signal processing applications,</span>
<span class="sd">    including in anti-aliasing, in the construction of a Lanczos resampling</span>
<span class="sd">    filter, and in interpolation.</span>

<span class="sd">    For bandlimited interpolation of discrete-time signals, the ideal</span>
<span class="sd">    interpolation kernel is proportional to the sinc function.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Weisstein, Eric W. &quot;Sinc Function.&quot; From MathWorld--A Wolfram Web</span>
<span class="sd">           Resource. http://mathworld.wolfram.com/SincFunction.html</span>
<span class="sd">    .. [2] Wikipedia, &quot;Sinc function&quot;,</span>
<span class="sd">           http://en.wikipedia.org/wiki/Sinc_function</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.linspace(-4, 4, 41)</span>
<span class="sd">    &gt;&gt;&gt; np.sinc(x)</span>
<span class="sd">    array([ -3.89804309e-17,  -4.92362781e-02,  -8.40918587e-02,</span>
<span class="sd">            -8.90384387e-02,  -5.84680802e-02,   3.89804309e-17,</span>
<span class="sd">             6.68206631e-02,   1.16434881e-01,   1.26137788e-01,</span>
<span class="sd">             8.50444803e-02,  -3.89804309e-17,  -1.03943254e-01,</span>
<span class="sd">            -1.89206682e-01,  -2.16236208e-01,  -1.55914881e-01,</span>
<span class="sd">             3.89804309e-17,   2.33872321e-01,   5.04551152e-01,</span>
<span class="sd">             7.56826729e-01,   9.35489284e-01,   1.00000000e+00,</span>
<span class="sd">             9.35489284e-01,   7.56826729e-01,   5.04551152e-01,</span>
<span class="sd">             2.33872321e-01,   3.89804309e-17,  -1.55914881e-01,</span>
<span class="sd">            -2.16236208e-01,  -1.89206682e-01,  -1.03943254e-01,</span>
<span class="sd">            -3.89804309e-17,   8.50444803e-02,   1.26137788e-01,</span>
<span class="sd">             1.16434881e-01,   6.68206631e-02,   3.89804309e-17,</span>
<span class="sd">            -5.84680802e-02,  -8.90384387e-02,  -8.40918587e-02,</span>
<span class="sd">            -4.92362781e-02,  -3.89804309e-17])</span>

<span class="sd">    &gt;&gt;&gt; plt.plot(x, np.sinc(x))</span>
<span class="sd">    [&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&quot;Sinc Function&quot;)</span>
<span class="sd">    &lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&quot;Amplitude&quot;)</span>
<span class="sd">    &lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&quot;X&quot;)</span>
<span class="sd">    &lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    It works in 2-D as well:</span>

<span class="sd">    &gt;&gt;&gt; x = np.linspace(-4, 4, 401)</span>
<span class="sd">    &gt;&gt;&gt; xx = np.outer(x, x)</span>
<span class="sd">    &gt;&gt;&gt; plt.imshow(np.sinc(xx))</span>
<span class="sd">    &lt;matplotlib.image.AxesImage object at 0x...&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">where</span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">1.0e-20</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sin</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">/</span><span class="n">y</span>


<span class="k">def</span> <span class="nf">msort</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a copy of an array sorted along the first axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Array to be sorted.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sorted_array : ndarray</span>
<span class="sd">        Array of the same type and shape as `a`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    sort</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    ``np.msort(a)`` is equivalent to  ``np.sort(a, axis=0)``.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">b</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">b</span>


<span class="k">def</span> <span class="nf">_ureduce</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Internal Function.</span>
<span class="sd">    Call `func` with `a` as first argument swapping the axes to use extended</span>
<span class="sd">    axis on functions that don&#39;t support it natively.</span>

<span class="sd">    Returns result and a.shape with axis dims set to 1.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input array or object that can be converted to an array.</span>
<span class="sd">    func : callable</span>
<span class="sd">        Reduction function Kapable of receiving an axis argument.</span>
<span class="sd">        It is is called with `a` as first argument followed by `kwargs`.</span>
<span class="sd">     kwargs : keyword arguments</span>
<span class="sd">        additional keyword arguments to pass to `func`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : tuple</span>
<span class="sd">        Result of func(a, **kwargs) and a.shape with axis dims set to 1</span>
<span class="sd">        which can be used to reshape the result to the same shape a ufunc with</span>
<span class="sd">        keepdims=True would produce.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;axis&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">keepdim</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">nd</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="o">&gt;=</span> <span class="n">nd</span> <span class="ow">or</span> <span class="n">axis</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">nd</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;axis </span><span class="si">%d</span><span class="s2"> out of bounds (</span><span class="si">%d</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
            <span class="n">keepdim</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">sax</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">axis</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">nd</span> <span class="ow">or</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">nd</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;axis </span><span class="si">%d</span><span class="s2"> out of bounds (</span><span class="si">%d</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">nd</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sax</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;duplicate value in axis&quot;</span><span class="p">)</span>
                <span class="n">sax</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">x</span> <span class="o">%</span> <span class="n">nd</span><span class="p">)</span>
                <span class="n">keepdim</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">keep</span> <span class="o">=</span> <span class="n">sax</span><span class="o">.</span><span class="n">symmetric_difference</span><span class="p">(</span><span class="nb">frozenset</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nd</span><span class="p">)))</span>
            <span class="n">nkeep</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">keep</span><span class="p">)</span>
            <span class="c1"># swap axis that should not be reduced to front</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">keep</span><span class="p">)):</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
            <span class="c1"># merge reduced axis</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">nkeep</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,))</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;axis&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">keepdim</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span>

    <span class="n">r</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">,</span> <span class="n">keepdim</span>


<span class="k">def</span> <span class="nf">median</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the median along the specified axis.</span>

<span class="sd">    Returns the median of the array elements.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input array or object that can be converted to an array.</span>
<span class="sd">    axis : int or sequence of int, optional</span>
<span class="sd">        Axis along which the medians are computed. The default (axis=None)</span>
<span class="sd">        is to compute the median along a flattened version of the array.</span>
<span class="sd">        A sequence of axes is supported since version 1.9.0.</span>
<span class="sd">    out : ndarray, optional</span>
<span class="sd">        Alternative output array in which to place the result. It must have</span>
<span class="sd">        the same shape and buffer length as the expected output, but the</span>
<span class="sd">        type (of the output) will be cast if necessary.</span>
<span class="sd">    overwrite_input : bool, optional</span>
<span class="sd">       If True, then allow use of memory of input array (a) for</span>
<span class="sd">       calculations. The input array will be modified by the call to</span>
<span class="sd">       median. This will save memory when you do not need to preserve the</span>
<span class="sd">       contents of the input array. Treat the input as undefined, but it</span>
<span class="sd">       will probably be fully or partially sorted. Default is False. Note</span>
<span class="sd">       that, if `overwrite_input` is True and the input is not already an</span>
<span class="sd">       ndarray, an error will be raised.</span>
<span class="sd">    keepdims : bool, optional</span>
<span class="sd">        If this is set to True, the axes which are reduced are left</span>
<span class="sd">        in the result as dimensions with size one. With this option,</span>
<span class="sd">        the result will broadcast correctly against the original `arr`.</span>

<span class="sd">        .. versionadded:: 1.9.0</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    median : ndarray</span>
<span class="sd">        A new array holding the result (unless `out` is specified, in which</span>
<span class="sd">        case that array is returned instead).  If the input contains</span>
<span class="sd">        integers, or floats of smaller precision than 64, then the output</span>
<span class="sd">        data-type is float64.  Otherwise, the output data-type is the same</span>
<span class="sd">        as that of the input.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    mean, percentile</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Given a vector V of length N, the median of V is the middle value of</span>
<span class="sd">    a sorted copy of V, ``V_sorted`` - i.e., ``V_sorted[(N-1)/2]``, when N is</span>
<span class="sd">    odd.  When N is even, it is the average of the two middle values of</span>
<span class="sd">    ``V_sorted``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[10, 7, 4], [3, 2, 1]])</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[10,  7,  4],</span>
<span class="sd">           [ 3,  2,  1]])</span>
<span class="sd">    &gt;&gt;&gt; np.median(a)</span>
<span class="sd">    3.5</span>
<span class="sd">    &gt;&gt;&gt; np.median(a, axis=0)</span>
<span class="sd">    array([ 6.5,  4.5,  2.5])</span>
<span class="sd">    &gt;&gt;&gt; np.median(a, axis=1)</span>
<span class="sd">    array([ 7.,  2.])</span>
<span class="sd">    &gt;&gt;&gt; m = np.median(a, axis=0)</span>
<span class="sd">    &gt;&gt;&gt; out = np.zeros_like(m)</span>
<span class="sd">    &gt;&gt;&gt; np.median(a, axis=0, out=m)</span>
<span class="sd">    array([ 6.5,  4.5,  2.5])</span>
<span class="sd">    &gt;&gt;&gt; m</span>
<span class="sd">    array([ 6.5,  4.5,  2.5])</span>
<span class="sd">    &gt;&gt;&gt; b = a.copy()</span>
<span class="sd">    &gt;&gt;&gt; np.median(b, axis=1, overwrite_input=True)</span>
<span class="sd">    array([ 7.,  2.])</span>
<span class="sd">    &gt;&gt;&gt; assert not np.all(a==b)</span>
<span class="sd">    &gt;&gt;&gt; b = a.copy()</span>
<span class="sd">    &gt;&gt;&gt; np.median(b, axis=None, overwrite_input=True)</span>
<span class="sd">    3.5</span>
<span class="sd">    &gt;&gt;&gt; assert not np.all(a==b)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">r</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">_ureduce</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="n">_median</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
                    <span class="n">overwrite_input</span><span class="o">=</span><span class="n">overwrite_input</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">keepdims</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">r</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">r</span>

<span class="k">def</span> <span class="nf">_median</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="c1"># can&#39;t be reasonably be implemented in terms of percentile as we have to</span>
    <span class="c1"># call mean to not break astropy</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="c1"># Set the partition indexes</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">sz</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">size</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sz</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">sz</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">szh</span> <span class="o">=</span> <span class="n">sz</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">kth</span> <span class="o">=</span> <span class="p">[</span><span class="n">szh</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">szh</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">kth</span> <span class="o">=</span> <span class="p">[(</span><span class="n">sz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span>
    <span class="c1"># Check if the array contains any nan&#39;s</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inexact</span><span class="p">):</span>
        <span class="n">kth</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">overwrite_input</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">part</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">part</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="n">kth</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">a</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="n">kth</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
            <span class="n">part</span> <span class="o">=</span> <span class="n">a</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">part</span> <span class="o">=</span> <span class="n">partition</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">kth</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">part</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">():</span>
        <span class="c1"># make 0-D arrays work</span>
        <span class="k">return</span> <span class="n">part</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">indexer</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">part</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">part</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="n">part</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># index with slice to allow mean (below) to work</span>
        <span class="n">indexer</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">indexer</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">index</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Check if the array contains any nan&#39;s</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inexact</span><span class="p">)</span> <span class="ow">and</span> <span class="n">sz</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># warn and return nans like mean would</span>
        <span class="n">rout</span> <span class="o">=</span> <span class="n">mean</span><span class="p">(</span><span class="n">part</span><span class="p">[</span><span class="n">indexer</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
        <span class="n">part</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">part</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">part</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">part</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">rout</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Invalid value encountered in median&quot;</span><span class="p">,</span>
                              <span class="ne">RuntimeWarning</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">out</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
                    <span class="n">rout</span> <span class="o">=</span> <span class="n">out</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">rout</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Invalid value encountered in median for&quot;</span> <span class="o">+</span>
                          <span class="s2">&quot; </span><span class="si">%d</span><span class="s2"> results&quot;</span> <span class="o">%</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">ravel</span><span class="p">()),</span>
                          <span class="ne">RuntimeWarning</span><span class="p">)</span>
            <span class="n">rout</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">return</span> <span class="n">rout</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># if there are no nans</span>
        <span class="c1"># Use mean in odd and even case to coerce data type</span>
        <span class="c1"># and check, use out array.</span>
        <span class="k">return</span> <span class="n">mean</span><span class="p">(</span><span class="n">part</span><span class="p">[</span><span class="n">indexer</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">percentile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
               <span class="n">overwrite_input</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the qth percentile of the data along the specified axis.</span>

<span class="sd">    Returns the qth percentile of the array elements.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input array or object that can be converted to an array.</span>
<span class="sd">    q : float in range of [0,100] (or sequence of floats)</span>
<span class="sd">        Percentile to compute which must be between 0 and 100 inclusive.</span>
<span class="sd">    axis : int or sequence of int, optional</span>
<span class="sd">        Axis along which the percentiles are computed. The default (None)</span>
<span class="sd">        is to compute the percentiles along a flattened version of the array.</span>
<span class="sd">        A sequence of axes is supported since version 1.9.0.</span>
<span class="sd">    out : ndarray, optional</span>
<span class="sd">        Alternative output array in which to place the result. It must</span>
<span class="sd">        have the same shape and buffer length as the expected output,</span>
<span class="sd">        but the type (of the output) will be cast if necessary.</span>
<span class="sd">    overwrite_input : bool, optional</span>
<span class="sd">        If True, then allow use of memory of input array `a` for</span>
<span class="sd">        calculations. The input array will be modified by the call to</span>
<span class="sd">        percentile. This will save memory when you do not need to preserve</span>
<span class="sd">        the contents of the input array. In this case you should not make</span>
<span class="sd">        any assumptions about the content of the passed in array `a` after</span>
<span class="sd">        this function completes -- treat it as undefined. Default is False.</span>
<span class="sd">        Note that, if the `a` input is not already an array this parameter</span>
<span class="sd">        will have no effect, `a` will be converted to an array internally</span>
<span class="sd">        regardless of the value of this parameter.</span>
<span class="sd">    interpolation : {&#39;linear&#39;, &#39;lower&#39;, &#39;higher&#39;, &#39;midpoint&#39;, &#39;nearest&#39;}</span>
<span class="sd">        This optional parameter specifies the interpolation method to use,</span>
<span class="sd">        when the desired quantile lies between two data points `i` and `j`:</span>
<span class="sd">            * linear: `i + (j - i) * fraction`, where `fraction` is the</span>
<span class="sd">              fractional part of the index surrounded by `i` and `j`.</span>
<span class="sd">            * lower: `i`.</span>
<span class="sd">            * higher: `j`.</span>
<span class="sd">            * nearest: `i` or `j` whichever is nearest.</span>
<span class="sd">            * midpoint: (`i` + `j`) / 2.</span>

<span class="sd">        .. versionadded:: 1.9.0</span>
<span class="sd">    keepdims : bool, optional</span>
<span class="sd">        If this is set to True, the axes which are reduced are left</span>
<span class="sd">        in the result as dimensions with size one. With this option,</span>
<span class="sd">        the result will broadcast correctly against the original array `a`.</span>

<span class="sd">        .. versionadded:: 1.9.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    percentile : scalar or ndarray</span>
<span class="sd">        If a single percentile `q` is given and axis=None a scalar is</span>
<span class="sd">        returned.  If multiple percentiles `q` are given an array holding</span>
<span class="sd">        the result is returned. The results are listed in the first axis.</span>
<span class="sd">        (If `out` is specified, in which case that array is returned</span>
<span class="sd">        instead).  If the input contains integers, or floats of smaller</span>
<span class="sd">        precision than 64, then the output data-type is float64. Otherwise,</span>
<span class="sd">        the output data-type is the same as that of the input.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    mean, median</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Given a vector V of length N, the q-th percentile of V is the q-th ranked</span>
<span class="sd">    value in a sorted copy of V.  The values and distances of the two</span>
<span class="sd">    nearest neighbors as well as the `interpolation` parameter will</span>
<span class="sd">    determine the percentile if the normalized ranking does not match q</span>
<span class="sd">    exactly. This function is the same as the median if ``q=50``, the same</span>
<span class="sd">    as the minimum if ``q=0`` and the same as the maximum if ``q=100``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[10, 7, 4], [3, 2, 1]])</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[10,  7,  4],</span>
<span class="sd">           [ 3,  2,  1]])</span>
<span class="sd">    &gt;&gt;&gt; np.percentile(a, 50)</span>
<span class="sd">    array([ 3.5])</span>
<span class="sd">    &gt;&gt;&gt; np.percentile(a, 50, axis=0)</span>
<span class="sd">    array([[ 6.5,  4.5,  2.5]])</span>
<span class="sd">    &gt;&gt;&gt; np.percentile(a, 50, axis=1)</span>
<span class="sd">    array([[ 7.],</span>
<span class="sd">           [ 2.]])</span>

<span class="sd">    &gt;&gt;&gt; m = np.percentile(a, 50, axis=0)</span>
<span class="sd">    &gt;&gt;&gt; out = np.zeros_like(m)</span>
<span class="sd">    &gt;&gt;&gt; np.percentile(a, 50, axis=0, out=m)</span>
<span class="sd">    array([[ 6.5,  4.5,  2.5]])</span>
<span class="sd">    &gt;&gt;&gt; m</span>
<span class="sd">    array([[ 6.5,  4.5,  2.5]])</span>

<span class="sd">    &gt;&gt;&gt; b = a.copy()</span>
<span class="sd">    &gt;&gt;&gt; np.percentile(b, 50, axis=1, overwrite_input=True)</span>
<span class="sd">    array([[ 7.],</span>
<span class="sd">           [ 2.]])</span>
<span class="sd">    &gt;&gt;&gt; assert not np.all(a==b)</span>
<span class="sd">    &gt;&gt;&gt; b = a.copy()</span>
<span class="sd">    &gt;&gt;&gt; np.percentile(b, 50, axis=None, overwrite_input=True)</span>
<span class="sd">    array([ 3.5])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">r</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">_ureduce</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="n">_percentile</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="n">q</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
                    <span class="n">overwrite_input</span><span class="o">=</span><span class="n">overwrite_input</span><span class="p">,</span>
                    <span class="n">interpolation</span><span class="o">=</span><span class="n">interpolation</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">keepdims</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">q</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">r</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">r</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">)]</span> <span class="o">+</span> <span class="n">k</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">r</span>


<span class="k">def</span> <span class="nf">_percentile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                <span class="n">overwrite_input</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">q</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Do not allow 0-d arrays because following code fails for scalar</span>
        <span class="n">zerod</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="bp">None</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">zerod</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="c1"># avoid expensive reductions, relevant for arrays with &lt; O(1000) elements</span>
    <span class="k">if</span> <span class="n">q</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.</span> <span class="ow">or</span> <span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">100.</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Percentiles must be in the range [0,100]&quot;</span><span class="p">)</span>
            <span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/=</span> <span class="mf">100.</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># faster than any()</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">q</span> <span class="o">&lt;</span> <span class="mf">0.</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">q</span> <span class="o">&gt;</span> <span class="mf">100.</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Percentiles must be in the range [0,100]&quot;</span><span class="p">)</span>
        <span class="n">q</span> <span class="o">/=</span> <span class="mf">100.</span>

    <span class="c1"># prepare a for partioning</span>
    <span class="k">if</span> <span class="n">overwrite_input</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">ap</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ap</span> <span class="o">=</span> <span class="n">a</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">ap</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ap</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">Nx</span> <span class="o">=</span> <span class="n">ap</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">q</span> <span class="o">*</span> <span class="p">(</span><span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># round fractional indices according to interpolation method</span>
    <span class="k">if</span> <span class="n">interpolation</span> <span class="o">==</span> <span class="s1">&#39;lower&#39;</span><span class="p">:</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">intp</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">interpolation</span> <span class="o">==</span> <span class="s1">&#39;higher&#39;</span><span class="p">:</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">ceil</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">intp</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">interpolation</span> <span class="o">==</span> <span class="s1">&#39;midpoint&#39;</span><span class="p">:</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span>
    <span class="k">elif</span> <span class="n">interpolation</span> <span class="o">==</span> <span class="s1">&#39;nearest&#39;</span><span class="p">:</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">around</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">intp</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">interpolation</span> <span class="o">==</span> <span class="s1">&#39;linear&#39;</span><span class="p">:</span>
        <span class="k">pass</span>  <span class="c1"># keep index as fraction and interpolate</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;interpolation can only be &#39;linear&#39;, &#39;lower&#39; &#39;higher&#39;, &quot;</span>
            <span class="s2">&quot;&#39;midpoint&#39;, or &#39;nearest&#39;&quot;</span><span class="p">)</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span> <span class="c1"># check for nan&#39;s flag</span>
    <span class="k">if</span> <span class="n">indices</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">intp</span><span class="p">:</span>  <span class="c1"># take the points along axis</span>
        <span class="c1"># Check if the array contains any nan&#39;s</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inexact</span><span class="p">):</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">indices</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

        <span class="n">ap</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="c1"># ensure axis with qth is first</span>
        <span class="n">ap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Check if the array contains any nan&#39;s</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inexact</span><span class="p">):</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">ap</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:,</span> <span class="o">...</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">zerod</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">take</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>


    <span class="k">else</span><span class="p">:</span>  <span class="c1"># weight the points above and below the indices</span>
        <span class="n">indices_below</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">intp</span><span class="p">)</span>
        <span class="n">indices_above</span> <span class="o">=</span> <span class="n">indices_below</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">indices_above</span><span class="p">[</span><span class="n">indices_above</span> <span class="o">&gt;</span> <span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="c1"># Check if the array contains any nan&#39;s</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inexact</span><span class="p">):</span>
            <span class="n">indices_above</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">indices_above</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

        <span class="n">weights_above</span> <span class="o">=</span> <span class="n">indices</span> <span class="o">-</span> <span class="n">indices_below</span>
        <span class="n">weights_below</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">weights_above</span>

        <span class="n">weights_shape</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">]</span> <span class="o">*</span> <span class="n">ap</span><span class="o">.</span><span class="n">ndim</span>
        <span class="n">weights_shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="n">weights_below</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">weights_shape</span>
        <span class="n">weights_above</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">weights_shape</span>

        <span class="n">ap</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="n">concatenate</span><span class="p">((</span><span class="n">indices_below</span><span class="p">,</span> <span class="n">indices_above</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

        <span class="c1"># ensure axis with qth is first</span>
        <span class="n">ap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">weights_below</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">weights_below</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">weights_above</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">weights_above</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Check if the array contains any nan&#39;s</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inexact</span><span class="p">):</span>
            <span class="n">indices_above</span> <span class="o">=</span> <span class="n">indices_above</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">ap</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:,</span> <span class="o">...</span><span class="p">])</span>

        <span class="n">x1</span> <span class="o">=</span> <span class="n">take</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">indices_below</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span> <span class="o">*</span> <span class="n">weights_below</span>
        <span class="n">x2</span> <span class="o">=</span> <span class="n">take</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">indices_above</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span> <span class="o">*</span> <span class="n">weights_above</span>

        <span class="c1"># ensure axis with qth is first</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">zerod</span><span class="p">:</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="n">x1</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">x2</span> <span class="o">=</span> <span class="n">x2</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Invalid value encountered in median&quot;</span><span class="p">,</span>
                              <span class="ne">RuntimeWarning</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">zerod</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ap</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">out</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
                    <span class="n">r</span> <span class="o">=</span> <span class="n">out</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">r</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">r</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">r</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">r</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">r</span>


<span class="k">def</span> <span class="nf">trapz</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Integrate along the given axis using the composite trapezoidal rule.</span>

<span class="sd">    Integrate `y` (`x`) along given axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : array_like</span>
<span class="sd">        Input array to integrate.</span>
<span class="sd">    x : array_like, optional</span>
<span class="sd">        If `x` is None, then spacing between all `y` elements is `dx`.</span>
<span class="sd">    dx : scalar, optional</span>
<span class="sd">        If `x` is None, spacing given by `dx` is assumed. Default is 1.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Specify the axis.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    trapz : float</span>
<span class="sd">        Definite integral as approximated by trapezoidal rule.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    sum, cumsum</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Image [2]_ illustrates trapezoidal rule -- y-axis locations of points</span>
<span class="sd">    will be taken from `y` array, by default x-axis distances between</span>
<span class="sd">    points will be 1.0, alternatively they can be provided with `x` array</span>
<span class="sd">    or with `dx` scalar.  Return value will be equal to combined area under</span>
<span class="sd">    the red lines.</span>


<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Wikipedia page: http://en.wikipedia.org/wiki/Trapezoidal_rule</span>

<span class="sd">    .. [2] Illustration image:</span>
<span class="sd">           http://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.trapz([1,2,3])</span>
<span class="sd">    4.0</span>
<span class="sd">    &gt;&gt;&gt; np.trapz([1,2,3], x=[4,6,8])</span>
<span class="sd">    8.0</span>
<span class="sd">    &gt;&gt;&gt; np.trapz([1,2,3], dx=2)</span>
<span class="sd">    8.0</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(6).reshape(2, 3)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[0, 1, 2],</span>
<span class="sd">           [3, 4, 5]])</span>
<span class="sd">    &gt;&gt;&gt; np.trapz(a, axis=0)</span>
<span class="sd">    array([ 1.5,  2.5,  3.5])</span>
<span class="sd">    &gt;&gt;&gt; np.trapz(a, axis=1)</span>
<span class="sd">    array([ 2.,  8.])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">asanyarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">dx</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">asanyarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="c1"># reshape to correct shape</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">y</span><span class="o">.</span><span class="n">ndim</span>
            <span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">nd</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">slice1</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">)]</span><span class="o">*</span><span class="n">nd</span>
    <span class="n">slice2</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">)]</span><span class="o">*</span><span class="n">nd</span>
    <span class="n">slice1</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
    <span class="n">slice2</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">slice1</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="n">slice2</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="c1"># Operations didn&#39;t work, cast to ndarray</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">add</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">d</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">slice1</span><span class="p">]</span><span class="o">+</span><span class="n">y</span><span class="p">[</span><span class="n">slice2</span><span class="p">])</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ret</span>


<span class="c1">#always succeed</span>
<span class="k">def</span> <span class="nf">add_newdoc</span><span class="p">(</span><span class="n">place</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">doc</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Adds documentation to obj which is in module place.</span>

<span class="sd">    If doc is a string add it to obj as a docstring</span>

<span class="sd">    If doc is a tuple, then the first element is interpreted as</span>
<span class="sd">       an attribute of obj and the second as the docstring</span>
<span class="sd">          (method, docstring)</span>

<span class="sd">    If doc is a list, then each element of the list should be a</span>
<span class="sd">       sequence of length two --&gt; [(method1, docstring1),</span>
<span class="sd">       (method2, docstring2), ...]</span>

<span class="sd">    This routine never raises an error.</span>

<span class="sd">    This routine cannot modify read-only docstrings, as appear</span>
<span class="sd">    in new-style classes or built-in functions. Because this</span>
<span class="sd">    routine never raises an error the caller must check manually</span>
<span class="sd">    that the docstrings were changed.</span>
<span class="sd">       &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">new</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="nb">__import__</span><span class="p">(</span><span class="n">place</span><span class="p">,</span> <span class="nb">globals</span><span class="p">(),</span> <span class="p">{},</span> <span class="p">[</span><span class="n">obj</span><span class="p">]),</span> <span class="n">obj</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">add_docstring</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">doc</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">add_docstring</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">doc</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">doc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">doc</span><span class="p">:</span>
                <span class="n">add_docstring</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">val</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">pass</span>


<span class="c1"># Based on scitools meshgrid</span>
<span class="k">def</span> <span class="nf">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">xi</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return coordinate matrices from coordinate vectors.</span>

<span class="sd">    Make N-D coordinate arrays for vectorized evaluations of</span>
<span class="sd">    N-D scalar/vector fields over N-D grids, given</span>
<span class="sd">    one-dimensional coordinate arrays x1, x2,..., xn.</span>

<span class="sd">    .. versionchanged:: 1.9</span>
<span class="sd">       1-D and 0-D cases are allowed.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1, x2,..., xn : array_like</span>
<span class="sd">        1-D arrays representing the coordinates of a grid.</span>
<span class="sd">    indexing : {&#39;xy&#39;, &#39;ij&#39;}, optional</span>
<span class="sd">        Cartesian (&#39;xy&#39;, default) or matrix (&#39;ij&#39;) indexing of output.</span>
<span class="sd">        See Notes for more details.</span>

<span class="sd">        .. versionadded:: 1.7.0</span>
<span class="sd">    sparse : bool, optional</span>
<span class="sd">        If True a sparse grid is returned in order to conserve memory.</span>
<span class="sd">        Default is False.</span>

<span class="sd">        .. versionadded:: 1.7.0</span>
<span class="sd">    copy : bool, optional</span>
<span class="sd">        If False, a view into the original arrays are returned in order to</span>
<span class="sd">        conserve memory.  Default is True.  Please note that</span>
<span class="sd">        ``sparse=False, copy=False`` will likely return non-contiguous</span>
<span class="sd">        arrays.  Furthermore, more than one element of a broadcast array</span>
<span class="sd">        may refer to a single memory location.  If you need to write to the</span>
<span class="sd">        arrays, make copies first.</span>

<span class="sd">        .. versionadded:: 1.7.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    X1, X2,..., XN : ndarray</span>
<span class="sd">        For vectors `x1`, `x2`,..., &#39;xn&#39; with lengths ``Ni=len(xi)`` ,</span>
<span class="sd">        return ``(N1, N2, N3,...Nn)`` shaped arrays if indexing=&#39;ij&#39;</span>
<span class="sd">        or ``(N2, N1, N3,...Nn)`` shaped arrays if indexing=&#39;xy&#39;</span>
<span class="sd">        with the elements of `xi` repeated to fill the matrix along</span>
<span class="sd">        the first dimension for `x1`, the second for `x2` and so on.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function supports both indexing conventions through the indexing</span>
<span class="sd">    keyword argument.  Giving the string &#39;ij&#39; returns a meshgrid with</span>
<span class="sd">    matrix indexing, while &#39;xy&#39; returns a meshgrid with Cartesian indexing.</span>
<span class="sd">    In the 2-D case with inputs of length M and N, the outputs are of shape</span>
<span class="sd">    (N, M) for &#39;xy&#39; indexing and (M, N) for &#39;ij&#39; indexing.  In the 3-D case</span>
<span class="sd">    with inputs of length M, N and P, outputs are of shape (N, M, P) for</span>
<span class="sd">    &#39;xy&#39; indexing and (M, N, P) for &#39;ij&#39; indexing.  The difference is</span>
<span class="sd">    illustrated by the following code snippet::</span>

<span class="sd">        xv, yv = meshgrid(x, y, sparse=False, indexing=&#39;ij&#39;)</span>
<span class="sd">        for i in range(nx):</span>
<span class="sd">            for j in range(ny):</span>
<span class="sd">                # treat xv[i,j], yv[i,j]</span>

<span class="sd">        xv, yv = meshgrid(x, y, sparse=False, indexing=&#39;xy&#39;)</span>
<span class="sd">        for i in range(nx):</span>
<span class="sd">            for j in range(ny):</span>
<span class="sd">                # treat xv[j,i], yv[j,i]</span>

<span class="sd">    In the 1-D and 0-D case, the indexing and sparse keywords have no effect.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    index_tricks.mgrid : Construct a multi-dimensional &quot;meshgrid&quot;</span>
<span class="sd">                     using indexing notation.</span>
<span class="sd">    index_tricks.ogrid : Construct an open multi-dimensional &quot;meshgrid&quot;</span>
<span class="sd">                     using indexing notation.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; nx, ny = (3, 2)</span>
<span class="sd">    &gt;&gt;&gt; x = np.linspace(0, 1, nx)</span>
<span class="sd">    &gt;&gt;&gt; y = np.linspace(0, 1, ny)</span>
<span class="sd">    &gt;&gt;&gt; xv, yv = meshgrid(x, y)</span>
<span class="sd">    &gt;&gt;&gt; xv</span>
<span class="sd">    array([[ 0. ,  0.5,  1. ],</span>
<span class="sd">           [ 0. ,  0.5,  1. ]])</span>
<span class="sd">    &gt;&gt;&gt; yv</span>
<span class="sd">    array([[ 0.,  0.,  0.],</span>
<span class="sd">           [ 1.,  1.,  1.]])</span>
<span class="sd">    &gt;&gt;&gt; xv, yv = meshgrid(x, y, sparse=True)  # make sparse output arrays</span>
<span class="sd">    &gt;&gt;&gt; xv</span>
<span class="sd">    array([[ 0. ,  0.5,  1. ]])</span>
<span class="sd">    &gt;&gt;&gt; yv</span>
<span class="sd">    array([[ 0.],</span>
<span class="sd">           [ 1.]])</span>

<span class="sd">    `meshgrid` is very useful to evaluate functions on a grid.</span>

<span class="sd">    &gt;&gt;&gt; x = np.arange(-5, 5, 0.1)</span>
<span class="sd">    &gt;&gt;&gt; y = np.arange(-5, 5, 0.1)</span>
<span class="sd">    &gt;&gt;&gt; xx, yy = meshgrid(x, y, sparse=True)</span>
<span class="sd">    &gt;&gt;&gt; z = np.sin(xx**2 + yy**2) / (xx**2 + yy**2)</span>
<span class="sd">    &gt;&gt;&gt; h = plt.contourf(x,y,z)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span>

    <span class="n">copy_</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;copy&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
    <span class="n">sparse</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;sparse&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
    <span class="n">indexing</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;indexing&#39;</span><span class="p">,</span> <span class="s1">&#39;xy&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;meshgrid() got an unexpected keyword argument &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span>
                        <span class="o">%</span> <span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)[</span><span class="mi">0</span><span class="p">],))</span>

    <span class="k">if</span> <span class="n">indexing</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;xy&#39;</span><span class="p">,</span> <span class="s1">&#39;ij&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Valid values for `indexing` are &#39;xy&#39; and &#39;ij&#39;.&quot;</span><span class="p">)</span>

    <span class="n">s0</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="n">ndim</span>
    <span class="n">output</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">s0</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="n">s0</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">::])</span>
              <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">xi</span><span class="p">)]</span>

    <span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">output</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">indexing</span> <span class="o">==</span> <span class="s1">&#39;xy&#39;</span> <span class="ow">and</span> <span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># switch first and second axis</span>
        <span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span><span class="o">*</span><span class="p">(</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">output</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span><span class="o">*</span><span class="p">(</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">sparse</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">copy_</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">output</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">output</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Return the full N-D matrix (not only the 1-D vector)</span>
        <span class="k">if</span> <span class="n">copy_</span><span class="p">:</span>
            <span class="n">mult_fact</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">x</span> <span class="o">*</span> <span class="n">mult_fact</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">output</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span><span class="o">*</span><span class="n">output</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">delete</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a new array with sub-arrays along an axis deleted. For a one</span>
<span class="sd">    dimensional array, this returns those entries not returned by</span>
<span class="sd">    `arr[obj]`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : array_like</span>
<span class="sd">      Input array.</span>
<span class="sd">    obj : slice, int or array of ints</span>
<span class="sd">      Indicate which sub-arrays to remove.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">      The axis along which to delete the subarray defined by `obj`.</span>
<span class="sd">      If `axis` is None, `obj` is applied to the flattened array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray</span>
<span class="sd">        A copy of `arr` with the elements specified by `obj` removed. Note</span>
<span class="sd">        that `delete` does not occur in-place. If `axis` is None, `out` is</span>
<span class="sd">        a flattened array.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    insert : Insert elements into an array.</span>
<span class="sd">    append : Append elements at the end of an array.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Often it is preferable to use a boolean mask. For example:</span>

<span class="sd">    &gt;&gt;&gt; mask = np.ones(len(arr), dtype=bool)</span>
<span class="sd">    &gt;&gt;&gt; mask[[0,2,4]] = False</span>
<span class="sd">    &gt;&gt;&gt; result = arr[mask,...]</span>

<span class="sd">    Is equivalent to `np.delete(arr, [0,2,4], axis=0)`, but allows further</span>
<span class="sd">    use of `mask`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; arr = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])</span>
<span class="sd">    &gt;&gt;&gt; arr</span>
<span class="sd">    array([[ 1,  2,  3,  4],</span>
<span class="sd">           [ 5,  6,  7,  8],</span>
<span class="sd">           [ 9, 10, 11, 12]])</span>
<span class="sd">    &gt;&gt;&gt; np.delete(arr, 1, 0)</span>
<span class="sd">    array([[ 1,  2,  3,  4],</span>
<span class="sd">           [ 9, 10, 11, 12]])</span>

<span class="sd">    &gt;&gt;&gt; np.delete(arr, np.s_[::2], 1)</span>
<span class="sd">    array([[ 2,  4],</span>
<span class="sd">           [ 6,  8],</span>
<span class="sd">           [10, 12]])</span>
<span class="sd">    &gt;&gt;&gt; np.delete(arr, [1,3,5], None)</span>
<span class="sd">    array([ 1,  3,  5,  7,  8,  9, 10, 11, 12])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">wrap</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">ndarray</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">wrap</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">__array_wrap__</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>

    <span class="n">arr</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="n">ndim</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">ndim</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># 2013-09-24, 1.9</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;in the future the special handling of scalars will be removed &quot;</span>
            <span class="s2">&quot;from delete and raise an error&quot;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">wrap</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">wrap</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">arr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">slobj</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">)]</span><span class="o">*</span><span class="n">ndim</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
    <span class="n">newshape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
        <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
        <span class="n">xr</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
        <span class="n">numtodel</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xr</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">numtodel</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">wrap</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">wrap</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">arr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Invert if step is negative:</span>
        <span class="k">if</span> <span class="n">step</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">step</span> <span class="o">=</span> <span class="o">-</span><span class="n">step</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">xr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">xr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="n">newshape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">-=</span> <span class="n">numtodel</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">empty</span><span class="p">(</span><span class="n">newshape</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">fnc</span><span class="p">)</span>
        <span class="c1"># copy initial chunk</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">slobj</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span>
            <span class="n">new</span><span class="p">[</span><span class="n">slobj</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">slobj</span><span class="p">]</span>
        <span class="c1"># copy end chunck</span>
        <span class="k">if</span> <span class="n">stop</span> <span class="o">==</span> <span class="n">N</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">slobj</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">stop</span><span class="o">-</span><span class="n">numtodel</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
            <span class="n">slobj2</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">)]</span><span class="o">*</span><span class="n">ndim</span>
            <span class="n">slobj2</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">stop</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
            <span class="n">new</span><span class="p">[</span><span class="n">slobj</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">slobj2</span><span class="p">]</span>
        <span class="c1"># copy middle pieces</span>
        <span class="k">if</span> <span class="n">step</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># use array indexing.</span>
            <span class="n">keep</span> <span class="o">=</span> <span class="n">ones</span><span class="p">(</span><span class="n">stop</span><span class="o">-</span><span class="n">start</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="n">keep</span><span class="p">[:</span><span class="n">stop</span><span class="o">-</span><span class="n">start</span><span class="p">:</span><span class="n">step</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">slobj</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="o">-</span><span class="n">numtodel</span><span class="p">)</span>
            <span class="n">slobj2</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">)]</span><span class="o">*</span><span class="n">ndim</span>
            <span class="n">slobj2</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">slobj2</span><span class="p">]</span>
            <span class="n">slobj2</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">keep</span>
            <span class="n">new</span><span class="p">[</span><span class="n">slobj</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">slobj2</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">wrap</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">wrap</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">new</span>

    <span class="n">_obj</span> <span class="o">=</span> <span class="n">obj</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
    <span class="c1"># After removing the special handling of booleans and out of</span>
    <span class="c1"># bounds values, the conversion to the array can be removed.</span>
    <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;in the future insert will treat boolean arrays and array-likes &quot;</span>
            <span class="s2">&quot;as boolean index instead of casting it to integer&quot;</span><span class="p">,</span> <span class="ne">FutureWarning</span><span class="p">)</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">intp</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_obj</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">long</span><span class="p">,</span> <span class="n">integer</span><span class="p">)):</span>
        <span class="c1"># optimization for a single value</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">obj</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">N</span> <span class="ow">or</span> <span class="n">obj</span> <span class="o">&gt;=</span> <span class="n">N</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                <span class="s2">&quot;index </span><span class="si">%i</span><span class="s2"> is out of bounds for axis </span><span class="si">%i</span><span class="s2"> with &quot;</span>
                <span class="s2">&quot;size </span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">obj</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">obj</span> <span class="o">+=</span> <span class="n">N</span>
        <span class="n">newshape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">empty</span><span class="p">(</span><span class="n">newshape</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">fnc</span><span class="p">)</span>
        <span class="n">slobj</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>
        <span class="n">new</span><span class="p">[</span><span class="n">slobj</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">slobj</span><span class="p">]</span>
        <span class="n">slobj</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">slobj2</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">)]</span><span class="o">*</span><span class="n">ndim</span>
        <span class="n">slobj2</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">obj</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">new</span><span class="p">[</span><span class="n">slobj</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">slobj2</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_obj</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">intp</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">intp</span><span class="p">,</span> <span class="s1">&#39;same_kind&#39;</span><span class="p">):</span>
            <span class="c1"># obj.size = 1 special case always failed and would just</span>
            <span class="c1"># give superfluous warnings.</span>
            <span class="c1"># 2013-09-24, 1.9</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;using a non-integer array as obj in delete will result in an &quot;</span>
                <span class="s2">&quot;error in the future&quot;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">intp</span><span class="p">)</span>
        <span class="n">keep</span> <span class="o">=</span> <span class="n">ones</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="c1"># Test if there are out of bound indices, this is deprecated</span>
        <span class="n">inside_bounds</span> <span class="o">=</span> <span class="p">(</span><span class="n">obj</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">obj</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="n">N</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">inside_bounds</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="c1"># 2013-09-24, 1.9</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;in the future out of bounds indices will raise an error &quot;</span>
                <span class="s2">&quot;instead of being ignored by `numpy.delete`.&quot;</span><span class="p">,</span>
                <span class="ne">DeprecationWarning</span><span class="p">)</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="p">[</span><span class="n">inside_bounds</span><span class="p">]</span>
        <span class="n">positive_indices</span> <span class="o">=</span> <span class="n">obj</span> <span class="o">&gt;=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">positive_indices</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;in the future negative indices will not be ignored by &quot;</span>
                <span class="s2">&quot;`numpy.delete`.&quot;</span><span class="p">,</span> <span class="ne">FutureWarning</span><span class="p">)</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="p">[</span><span class="n">positive_indices</span><span class="p">]</span>

        <span class="n">keep</span><span class="p">[</span><span class="n">obj</span><span class="p">,</span> <span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">slobj</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">keep</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">slobj</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">wrap</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">wrap</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">new</span>


<span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Insert values along the given axis before the given indices.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    obj : int, slice or sequence of ints</span>
<span class="sd">        Object that defines the index or indices before which `values` is</span>
<span class="sd">        inserted.</span>

<span class="sd">        .. versionadded:: 1.8.0</span>

<span class="sd">        Support for multiple insertions when `obj` is a single scalar or a</span>
<span class="sd">        sequence with one element (similar to calling insert multiple</span>
<span class="sd">        times).</span>
<span class="sd">    values : array_like</span>
<span class="sd">        Values to insert into `arr`. If the type of `values` is different</span>
<span class="sd">        from that of `arr`, `values` is converted to the type of `arr`.</span>
<span class="sd">        `values` should be shaped so that ``arr[...,obj,...] = values``</span>
<span class="sd">        is legal.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis along which to insert `values`.  If `axis` is None then `arr`</span>
<span class="sd">        is flattened first.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray</span>
<span class="sd">        A copy of `arr` with `values` inserted.  Note that `insert`</span>
<span class="sd">        does not occur in-place: a new array is returned. If</span>
<span class="sd">        `axis` is None, `out` is a flattened array.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    append : Append elements at the end of an array.</span>
<span class="sd">    concatenate : Join a sequence of arrays along an existing axis.</span>
<span class="sd">    delete : Delete elements from an array.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Note that for higher dimensional inserts `obj=0` behaves very different</span>
<span class="sd">    from `obj=[0]` just like `arr[:,0,:] = values` is different from</span>
<span class="sd">    `arr[:,[0],:] = values`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[1, 1], [2, 2], [3, 3]])</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[1, 1],</span>
<span class="sd">           [2, 2],</span>
<span class="sd">           [3, 3]])</span>
<span class="sd">    &gt;&gt;&gt; np.insert(a, 1, 5)</span>
<span class="sd">    array([1, 5, 1, 2, 2, 3, 3])</span>
<span class="sd">    &gt;&gt;&gt; np.insert(a, 1, 5, axis=1)</span>
<span class="sd">    array([[1, 5, 1],</span>
<span class="sd">           [2, 5, 2],</span>
<span class="sd">           [3, 5, 3]])</span>

<span class="sd">    Difference between sequence and scalars:</span>

<span class="sd">    &gt;&gt;&gt; np.insert(a, [1], [[1],[2],[3]], axis=1)</span>
<span class="sd">    array([[1, 1, 1],</span>
<span class="sd">           [2, 2, 2],</span>
<span class="sd">           [3, 3, 3]])</span>
<span class="sd">    &gt;&gt;&gt; np.array_equal(np.insert(a, 1, [1, 2, 3], axis=1),</span>
<span class="sd">    ...                np.insert(a, [1], [[1],[2],[3]], axis=1))</span>
<span class="sd">    True</span>

<span class="sd">    &gt;&gt;&gt; b = a.flatten()</span>
<span class="sd">    &gt;&gt;&gt; b</span>
<span class="sd">    array([1, 1, 2, 2, 3, 3])</span>
<span class="sd">    &gt;&gt;&gt; np.insert(b, [2, 2], [5, 6])</span>
<span class="sd">    array([1, 1, 5, 6, 2, 2, 3, 3])</span>

<span class="sd">    &gt;&gt;&gt; np.insert(b, slice(2, 4), [5, 6])</span>
<span class="sd">    array([1, 1, 5, 2, 6, 2, 3, 3])</span>

<span class="sd">    &gt;&gt;&gt; np.insert(b, [2, 2], [7.13, False]) # type casting</span>
<span class="sd">    array([1, 1, 7, 0, 2, 2, 3, 3])</span>

<span class="sd">    &gt;&gt;&gt; x = np.arange(8).reshape(2, 4)</span>
<span class="sd">    &gt;&gt;&gt; idx = (1, 3)</span>
<span class="sd">    &gt;&gt;&gt; np.insert(x, idx, 999, axis=1)</span>
<span class="sd">    array([[  0, 999,   1,   2, 999,   3],</span>
<span class="sd">           [  4, 999,   5,   6, 999,   7]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">wrap</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">ndarray</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">wrap</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">__array_wrap__</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>

    <span class="n">arr</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="n">ndim</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">ndim</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">axis</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">ndim</span> <span class="ow">or</span> <span class="n">axis</span> <span class="o">&gt;=</span> <span class="n">ndim</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                <span class="s2">&quot;axis </span><span class="si">%i</span><span class="s2"> is out of bounds for an array of &quot;</span>
                <span class="s2">&quot;dimension </span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">ndim</span><span class="p">))</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">axis</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">axis</span> <span class="o">+=</span> <span class="n">ndim</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="c1"># 2013-09-24, 1.9</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;in the future the special handling of scalars will be removed &quot;</span>
            <span class="s2">&quot;from insert and raise an error&quot;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">arr</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span>
        <span class="k">if</span> <span class="n">wrap</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">wrap</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">arr</span>
    <span class="n">slobj</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">)]</span><span class="o">*</span><span class="n">ndim</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
    <span class="n">newshape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
        <span class="c1"># turn it into a range object</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="o">*</span><span class="n">obj</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">N</span><span class="p">),</span> <span class="o">**</span><span class="p">{</span><span class="s1">&#39;dtype&#39;</span><span class="p">:</span> <span class="n">intp</span><span class="p">})</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># need to copy obj, because indices will be changed in-place</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">indices</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="c1"># See also delete</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;in the future insert will treat boolean arrays and &quot;</span>
                <span class="s2">&quot;array-likes as a boolean index instead of casting it to &quot;</span>
                <span class="s2">&quot;integer&quot;</span><span class="p">,</span> <span class="ne">FutureWarning</span><span class="p">)</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">intp</span><span class="p">)</span>
            <span class="c1"># Code after warning period:</span>
            <span class="c1">#if obj.ndim != 1:</span>
            <span class="c1">#    raise ValueError(&#39;boolean array argument obj to insert &#39;</span>
            <span class="c1">#                     &#39;must be one dimensional&#39;)</span>
            <span class="c1">#indices = np.flatnonzero(obj)</span>
        <span class="k">elif</span> <span class="n">indices</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;index array argument obj to insert must be one dimensional &quot;</span>
                <span class="s2">&quot;or scalar&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">indices</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">N</span> <span class="ow">or</span> <span class="n">index</span> <span class="o">&gt;</span> <span class="n">N</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                <span class="s2">&quot;index </span><span class="si">%i</span><span class="s2"> is out of bounds for axis </span><span class="si">%i</span><span class="s2"> with &quot;</span>
                <span class="s2">&quot;size </span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">index</span> <span class="o">+=</span> <span class="n">N</span>

        <span class="c1"># There are some object array corner cases here, but we cannot avoid</span>
        <span class="c1"># that:</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="n">arr</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">indices</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># broadcasting is very different here, since a[:,0,:] = ... behaves</span>
            <span class="c1"># very different from a[:,[0],:] = ...! This changes values so that</span>
            <span class="c1"># it works likes the second case. (here a[:,0:1,:])</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">axis</span> <span class="o">%</span> <span class="n">values</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">numnew</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
        <span class="n">newshape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">+=</span> <span class="n">numnew</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">empty</span><span class="p">(</span><span class="n">newshape</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">fnc</span><span class="p">)</span>
        <span class="n">slobj</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
        <span class="n">new</span><span class="p">[</span><span class="n">slobj</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">slobj</span><span class="p">]</span>
        <span class="n">slobj</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">index</span><span class="o">+</span><span class="n">numnew</span><span class="p">)</span>
        <span class="n">new</span><span class="p">[</span><span class="n">slobj</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span>
        <span class="n">slobj</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">index</span><span class="o">+</span><span class="n">numnew</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">slobj2</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">ndim</span>
        <span class="n">slobj2</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">new</span><span class="p">[</span><span class="n">slobj</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">slobj2</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">wrap</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">wrap</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new</span>
    <span class="k">elif</span> <span class="n">indices</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="c1"># Can safely cast the empty list to intp</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">intp</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">intp</span><span class="p">,</span> <span class="s1">&#39;same_kind&#39;</span><span class="p">):</span>
        <span class="c1"># 2013-09-24, 1.9</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;using a non-integer array as obj in insert will result in an &quot;</span>
            <span class="s2">&quot;error in the future&quot;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">intp</span><span class="p">)</span>

    <span class="n">indices</span><span class="p">[</span><span class="n">indices</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">N</span>

    <span class="n">numnew</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="s1">&#39;mergesort&#39;</span><span class="p">)</span>   <span class="c1"># stable sort</span>
    <span class="n">indices</span><span class="p">[</span><span class="n">order</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">numnew</span><span class="p">)</span>

    <span class="n">newshape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">+=</span> <span class="n">numnew</span>
    <span class="n">old_mask</span> <span class="o">=</span> <span class="n">ones</span><span class="p">(</span><span class="n">newshape</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">old_mask</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="n">new</span> <span class="o">=</span> <span class="n">empty</span><span class="p">(</span><span class="n">newshape</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">fnc</span><span class="p">)</span>
    <span class="n">slobj2</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">)]</span><span class="o">*</span><span class="n">ndim</span>
    <span class="n">slobj</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">indices</span>
    <span class="n">slobj2</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">old_mask</span>
    <span class="n">new</span><span class="p">[</span><span class="n">slobj</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span>
    <span class="n">new</span><span class="p">[</span><span class="n">slobj2</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span>

    <span class="k">if</span> <span class="n">wrap</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">wrap</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">new</span>


<span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Append values to the end of an array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : array_like</span>
<span class="sd">        Values are appended to a copy of this array.</span>
<span class="sd">    values : array_like</span>
<span class="sd">        These values are appended to a copy of `arr`.  It must be of the</span>
<span class="sd">        correct shape (the same shape as `arr`, excluding `axis`).  If</span>
<span class="sd">        `axis` is not specified, `values` can be any shape and will be</span>
<span class="sd">        flattened before use.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        The axis along which `values` are appended.  If `axis` is not</span>
<span class="sd">        given, both `arr` and `values` are flattened before use.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    append : ndarray</span>
<span class="sd">        A copy of `arr` with `values` appended to `axis`.  Note that</span>
<span class="sd">        `append` does not occur in-place: a new array is allocated and</span>
<span class="sd">        filled.  If `axis` is None, `out` is a flattened array.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    insert : Insert elements into an array.</span>
<span class="sd">    delete : Delete elements from an array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.append([1, 2, 3], [[4, 5, 6], [7, 8, 9]])</span>
<span class="sd">    array([1, 2, 3, 4, 5, 6, 7, 8, 9])</span>

<span class="sd">    When `axis` is specified, `values` must have the correct shape.</span>

<span class="sd">    &gt;&gt;&gt; np.append([[1, 2, 3], [4, 5, 6]], [[7, 8, 9]], axis=0)</span>
<span class="sd">    array([[1, 2, 3],</span>
<span class="sd">           [4, 5, 6],</span>
<span class="sd">           [7, 8, 9]])</span>
<span class="sd">    &gt;&gt;&gt; np.append([[1, 2, 3], [4, 5, 6]], [7, 8, 9], axis=0)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: arrays must have same number of dimensions</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">asanyarray</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">1</span>
    <span class="k">return</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">arr</span><span class="p">,</span> <span class="n">values</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">acoustics 0.0 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2013, Frederik Rietdijk.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.4.
    </div>
  </body>
</html>